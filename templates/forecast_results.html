<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MARFOR - Результаты прогноза</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="/static/breadcrumbs.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* Стили для прогнозных данных */
        .forecast-row {
            background-color: #fff3cd !important;
        }
        
        .forecast-badge {
            background-color: #ffc107;
            color: #000;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: bold;
        }
        
        /* Мятный цвет для всех кнопок */
        .btn-primary {
            background-color: #81db99 !important;
            border-color: #81db99 !important;
            color: #000 !important;
        }
        
        .btn-primary:hover {
            background-color: #6bc884 !important;
            border-color: #6bc884 !important;
            color: #000 !important;
        }
        
        .btn-primary:focus {
            background-color: #6bc884 !important;
            border-color: #6bc884 !important;
            color: #000 !important;
            box-shadow: 0 0 0 0.2rem rgba(129, 219, 153, 0.25) !important;
        }
        
        .btn-primary:active {
            background-color: #55b96f !important;
            border-color: #55b96f !important;
            color: #000 !important;
        }
        
        .btn-success {
            background-color: #81db99 !important;
            border-color: #81db99 !important;
            color: #000 !important;
        }
        
        .btn-success:hover {
            background-color: #6bc884 !important;
            border-color: #6bc884 !important;
            color: #000 !important;
        }
        
        .btn-info {
            background-color: #81db99 !important;
            border-color: #81db99 !important;
            color: #000 !important;
        }
        
        .btn-info:hover {
            background-color: #6bc884 !important;
            border-color: #6bc884 !important;
            color: #000 !important;
        }
        
        .btn-warning {
            background-color: #81db99 !important;
            border-color: #81db99 !important;
            color: #000 !important;
        }
        
        .btn-warning:hover {
            background-color: #6bc884 !important;
            border-color: #6bc884 !important;
            color: #000 !important;
        }
        .module-card {
            transition: transform 0.3s ease;
            border: none;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            height: 100%;
        }
        .module-card:hover {
            transform: translateY(-5px);
        }
        .module-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }
        .upload-area {
            border: 2px dashed #667eea;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            transition: all 0.3s ease;
        }
        .upload-area:hover {
            border-color: #764ba2;
            background-color: #f8f9ff;
        }
        .config-section {
            background-color: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }
        .results-tabs {
            margin-top: 20px;
        }
        .chart-container {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin: 10px 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            position: relative;
            height: 400px;
        }
        
        .pivot-toggle {
            cursor: pointer;
            font-weight: bold;
            margin-right: 5px;
            color: #007bff;
        }
        
        .pivot-toggle:hover {
            color: #0056b3;
        }
        
        .pivot-header {
            cursor: pointer;
            user-select: none;
        }
        
        .pivot-row.collapsed {
            display: none;
        }
        
        .pivot-cell.hidden {
            display: none;
        }
        
        #pivotTable {
            table-layout: fixed;
            width: 100%;
        }
        
        #pivotTable th[style*="visibility: hidden"],
        #pivotTable td[style*="visibility: hidden"] {
            border: none !important;
        }
        
        #pivotTable th,
        #pivotTable td {
            transition: width 0.2s ease, padding 0.2s ease;
        }
        
        #pivotTable th,
        #pivotTable td {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .data-table {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin: 10px 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .table-responsive {
            max-height: 500px;
            overflow-y: auto;
        }
        
        /* Стили для таблицы с разбивкой по столбцам */
        .pivot-table-split-container {
            overflow-x: auto;
            overflow-y: auto;
            max-height: 300px;
            border: 1px solid #dee2e6;
            border-radius: 0.375rem;
            width: 100%;
        }
        
        .pivot-table-split {
            min-width: max-content;
            width: max-content;
            border-collapse: separate;
            border-spacing: 0;
        }
        
        /* Столбцы временных рядов */
        .pivot-table-split .time-column {
            background-color: #e9ecef !important;
            color: #212529 !important;
            border-right: 2px solid #adb5bd;
            white-space: nowrap;
            font-weight: 500;
            min-width: 80px;
            width: auto;
        }
        
        /* Столбцы метрик с адаптивной шириной */
        .pivot-table-split .metric-column {
            min-width: 120px;
            width: auto;
            white-space: nowrap;
            text-align: right;
            padding: 8px 12px;
        }
        
        /* Заголовки метрик */
        .pivot-table-split .metric-header {
            background-color: #007bff !important;
            color: white !important;
            font-weight: bold;
            text-align: center;
            border: 1px solid #0056b3;
        }
        
        /* Заголовки срезов */
        .pivot-table-split .slice-header {
            background-color: #6c757d !important;
            color: white !important;
            font-weight: 500;
            text-align: center;
            border: 1px solid #5a6268;
        }
        
        /* Общие заголовки сводной таблицы */
        .pivot-table-split .pivot-header {
            min-width: 120px;
            width: auto;
            text-align: center;
            background-color: #495057 !important;
            white-space: nowrap;
        }
        
        /* Заголовки временных рядов с иерархией */
        .pivot-table-split .time-header {
            background-color: #343a40 !important;
            color: white !important;
            font-weight: 500;
            text-align: left !important;
            padding-left: 10px;
        }
        
        /* Иконки коллапсирования */
        .collapse-icon {
            font-family: monospace;
            font-weight: bold;
            font-size: 14px;
            color: #fff;
            background-color: #007bff;
            border: 1px solid #0056b3;
            border-radius: 3px;
            padding: 2px 6px;
            margin-right: 8px;
            display: inline-block;
            min-width: 20px;
            text-align: center;
            user-select: none;
        }
        
        .collapse-icon:hover {
            background-color: #0056b3;
            border-color: #004085;
        }
        
        /* Стили для строки Total */
        .pivot-total-row {
            background-color: #f8f9fa !important;
            border-top: 2px solid #007bff !important;
            border-bottom: 2px solid #007bff !important;
        }
        
        .pivot-total-cell {
            background-color: #f8f9fa !important;
            font-weight: bold !important;
            border-top: 2px solid #007bff !important;
            border-bottom: 2px solid #007bff !important;
        }
        
        .pivot-total-row:hover {
            background-color: #e9ecef !important;
        }
        
        .pivot-total-cell:hover {
            background-color: #e9ecef !important;
        }
        
        /* Дополнительное визуальное разделение для Total вверху */
        .pivot-total-row td:first-child {
            font-weight: bold;
            color: #007bff;
            text-align: center;
        }
        
        /* Стили для фильтров */
        .filter-card {
            border: 1px solid #dee2e6;
            border-radius: 0.375rem;
            margin-bottom: 0.75rem;
            background-color: #f8f9fa;
        }
        
        .filter-header {
            background-color: #e9ecef;
            padding: 0.5rem 0.75rem;
            border-bottom: 1px solid #dee2e6;
            font-weight: 600;
            color: #495057;
            font-size: 0.875rem;
        }
        
        .filter-body {
            padding: 0.75rem;
        }
        
        .filter-checkbox-list {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            border-radius: 0.25rem;
            padding: 0.5rem;
            background-color: white;
        }
        
        .filter-checkbox-item {
            padding: 0.2rem 0;
            border-bottom: 1px solid #f8f9fa;
            font-size: 0.875rem;
        }
        
        .filter-checkbox-item:last-child {
            border-bottom: none;
        }
        
        .filter-slider-container {
            padding: 0.5rem 0;
        }
        
        .filter-slider-label {
            font-weight: 500;
            margin-bottom: 0.5rem;
            color: #495057;
        }
        
        .filter-slider-value {
            text-align: center;
            font-weight: bold;
            color: #007bff;
            margin-top: 0.5rem;
        }
        
        .filter-toggle {
            cursor: pointer;
            user-select: none;
        }
        
        .filter-toggle:hover {
            background-color: #e9ecef;
        }
        
        .filter-active {
            background-color: #d1ecf1 !important;
            border-color: #bee5eb !important;
        }
        
        .pivot-table-split .metric-subheader {
            min-width: 120px;
            width: auto;
            text-align: center;
            background-color: #6c757d !important;
            white-space: nowrap;
        }

        /* Стили для горизонтального скролла в стиле Google Analytics */
        .pivot-table-ga-container {
            overflow-x: auto;
            overflow-y: auto;
            max-height: 400px;
            width: 100%;
            border: 1px solid #dee2e6;
            border-radius: 0.375rem;
            position: relative;
        }
        
        /* Стилизация скроллбаров */
        .pivot-table-ga-container::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        .pivot-table-ga-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        
        .pivot-table-ga-container::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 4px;
        }
        
        .pivot-table-ga-container::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        .pivot-table-ga {
            min-width: max-content;
            width: max-content;
            border-collapse: separate;
            border-spacing: 0;
        }

        /* Фиксированные колонки времени */
        .pivot-table-ga .sticky-time-column {
            position: sticky;
            left: 0;
            z-index: 2;
            background-color: #e9ecef !important;
            color: #212529 !important;
            border-right: 2px solid #adb5bd;
            font-weight: 500;
            min-width: 80px;
            width: auto;
        }

        /* Фиксированные колонки метрик */
        .pivot-table-ga .sticky-metric-column {
            position: sticky;
            left: 80px; /* После первой колонки времени */
            z-index: 1;
            background-color: #f8f9fa !important;
            color: #212529 !important;
            border-right: 1px solid #dee2e6;
            min-width: 120px;
            width: auto;
            text-align: right;
            white-space: nowrap;
        }

        /* Обычные колонки метрик (не фиксированные) */
        .pivot-table-ga .scrollable-metric-column {
            min-width: 120px;
            width: auto;
            text-align: right;
            white-space: nowrap;
            background-color: #ffffff;
            border-right: 1px solid #dee2e6;
        }

        /* Заголовки */
        .pivot-table-ga .sticky-time-header {
            position: sticky;
            left: 0;
            z-index: 3;
            background-color: #495057 !important;
            color: white !important;
            border-right: 2px solid #adb5bd;
            font-weight: 600;
            min-width: 80px;
            width: auto;
        }

        .pivot-table-ga .sticky-metric-header {
            position: sticky;
            left: 80px;
            z-index: 2;
            background-color: #6c757d !important;
            color: white !important;
            border-right: 1px solid #495057;
            font-weight: 600;
            min-width: 120px;
            width: auto;
        }

        .pivot-table-ga .scrollable-metric-header {
            background-color: #6c757d !important;
            color: white !important;
            border-right: 1px solid #495057;
            font-weight: 600;
            min-width: 120px;
            width: auto;
        }

        /* Подзаголовки */
        .pivot-table-ga .sticky-metric-subheader {
            position: sticky;
            left: 80px;
            z-index: 2;
            background-color: #6c757d !important;
            color: white !important;
            border-right: 1px solid #495057;
            font-weight: 500;
            min-width: 120px;
            width: auto;
        }

        .pivot-table-ga .scrollable-metric-subheader {
            background-color: #6c757d !important;
            color: white !important;
            border-right: 1px solid #495057;
            font-weight: 500;
            min-width: 120px;
            width: auto;
        }
        .metric-card {
            background-color: #e3f2fd;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            text-align: center;
        }
        .metric-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #1976d2;
        }
        .dependency-matrix {
            overflow-x: auto;
        }
        .loading {
            text-align: center;
            padding: 40px;
        }
        .spinner-border {
            width: 3rem;
            height: 3rem;
        }
        .nav-tabs .nav-link.active {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
        }
        .nav-tabs .nav-link {
            color: #007bff;
        }
        .nav-tabs .nav-link:hover {
            border-color: #e9ecef #e9ecef #dee2e6;
        }
        .scenario-input {
            margin-bottom: 15px;
        }
        .download-section {
            background-color: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }
        
        /* Стили для дропбокса метрик */
        #metricsDropdownMenu {
            max-height: 300px;
            overflow-y: auto;
        }
        
        .metrics-checkbox-item {
            padding: 0.25rem 1rem;
            cursor: pointer;
        }
        
        .metrics-checkbox-item:hover {
            background-color: #f8f9fa;
        }
        
        .metrics-checkbox-item .form-check {
            margin: 0;
        }
        
        .metrics-checkbox-item .form-check-input {
            margin-right: 0.5rem;
        }
        
        /* Стили для дропбокса срезов */
        #slicesDropdownMenu {
            max-height: 300px;
            overflow-y: auto;
        }
        
        .slices-radio-item {
            padding: 0.25rem 1rem;
            cursor: pointer;
        }
        
        .slices-radio-item:hover {
            background-color: #f8f9fa;
        }
        
        .slices-radio-item .form-check {
            margin: 0;
        }
        
        .slices-radio-item .form-check-input {
            margin-right: 0.5rem;
        }
        
        /* Компактное отображение фильтров в сетке */
        #filtersContainer {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 0.75rem;
        }
        
        @media (max-width: 768px) {
            #filtersContainer {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- Навигация -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container">
            <a class="navbar-brand d-flex align-items-center" href="#">
                <img src="/static/images/logo.png" alt="MARFOR Logo" height="32" class="me-2" style="object-fit: contain;">
                <strong>MARFOR</strong>
            </a>
            <span class="navbar-text">Маркетинговый инструмент прогнозирования</span>
            <div class="ms-auto">
                <span class="badge bg-success" style="font-size: 0.8em;">
                    <i class="fas fa-code"></i> v2.21.0
                </span>
            </div>
        </div>
    </nav>

    <!-- Хлебные крошки -->
    <div id="breadcrumbContainer"></div>

    <!-- Основной контент -->
    <div class="container my-3">
        <!-- Область для отображения данных проекта -->
        <div id="dataPreview"></div>

        <!-- Загрузка данных -->
        <div class="card mb-4" id="uploadSection">
            <div class="card-header">
                <h4><i class="fas fa-upload me-2"></i>Загрузка данных</h4>
            </div>
            <div class="card-body">
                <div class="upload-area" id="uploadArea">
                    <i class="fas fa-cloud-upload-alt fa-3x text-muted mb-3"></i>
                    <h5>Создать новый проект</h5>
                    <p class="text-muted">Загрузите файл с данными для создания проекта</p>
                    <div class="mb-3">
                        <label for="projectNameInput" class="form-label">Название проекта</label>
                        <input type="text" class="form-control" id="projectNameInput" placeholder="Введите название проекта" required>
                    </div>
                    <input type="file" id="fileInput" class="d-none" accept=".csv,.xlsx,.xls">
                    <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()">
                        <i class="fas fa-folder-open me-2"></i>Выбрать файл
                    </button>
                </div>
                <div id="uploadStatus" class="mt-3"></div>
                <div id="dataPreview" class="mt-3"></div>
            </div>
        </div>

        <!-- Модуль 1: Трендовый прогноз -->
        <div class="card mb-4" id="trendModule" style="display: none;">
            <div class="card-header">
                <h4><i class="fas fa-chart-line me-2"></i>Модуль 1: Трендовый прогноз</h4>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-6">
                        <div class="config-section">
                            <h6>Настройки прогноза</h6>
                            <div class="mb-3">
                                <label class="form-label">Целевая метрика</label>
                                <select class="form-select" id="trendTargetMetric">
                                    <option value="revenue_total">revenue_total</option>
                                </select>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Количество периодов</label>
                                <input type="number" class="form-control" id="trendPeriods" value="16" min="1" max="60">
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Модель прогнозирования</label>
                                <select class="form-select" id="trendModel">
                                    <option value="hybrid">Гибридная (автовыбор)</option>
                                    <option value="prophet">Prophet</option>
                                    <option value="random_forest">Random Forest</option>
                                    <option value="linear">Линейная регрессия</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="config-section">
                            <h6>Параметры каскадной модели</h6>
                            <div class="form-check mb-2">
                                <input class="form-check-input" type="checkbox" id="enableCascade" checked>
                                <label class="form-check-label" for="enableCascade">
                                    Включить каскадную обработку
                                </label>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Уровень агрегации</label>
                                <select class="form-select" id="cascadeLevel">
                                    <option value="region_to">По регионам</option>
                                    <option value="subdivision">По подразделениям</option>
                                    <option value="category">По категориям</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="text-center">
                    <button class="btn btn-primary btn-lg" onclick="runTrendForecast()">
                        <i class="fas fa-chart-line me-2"></i>Запустить трендовый прогноз
                    </button>
                </div>
                <div id="trendResults" class="mt-4"></div>
            </div>
        </div>

        <!-- Модуль 2: Анализ зависимостей -->
        <div class="card mb-4" id="dependenciesModule" style="display: none;">
            <div class="card-header">
                <h4><i class="fas fa-link me-2"></i>Модуль 2: Анализ зависимостей</h4>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-6">
                        <div class="config-section">
                            <h6>Настройки анализа</h6>
                            <div class="mb-3">
                                <label class="form-label">Бюджетное поле</label>
                                <select class="form-select" id="budgetField">
                                    <option value="ads_cost">ads_cost</option>
                                </select>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Целевые метрики</label>
                                <div id="targetMetricsList"></div>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Метод анализа</label>
                                <select class="form-select" id="dependencyMethod">
                                    <option value="correlation">Корреляционный анализ</option>
                                    <option value="regression">Регрессионный анализ</option>
                                    <option value="causality">Анализ причинности</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="config-section">
                            <h6>Фильтры каналов</h6>
                            <div class="mb-3">
                                <label class="form-label">Платные каналы</label>
                                <input type="text" class="form-control" id="paidChannels" placeholder="paid_apps,paid_web">
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Органические каналы</label>
                                <input type="text" class="form-control" id="organicChannels" placeholder="organic_apps,organic_web">
                            </div>
                        </div>
                    </div>
                </div>
                <div class="text-center">
                    <button class="btn btn-success btn-lg" onclick="runDependencyAnalysis()">
                        <i class="fas fa-link me-2"></i>Анализировать зависимости
                    </button>
                </div>
                <div id="dependenciesResults" class="mt-4"></div>
            </div>
        </div>

        <!-- Модуль 3: Моделирование -->
        <div class="card mb-4" id="simulationModule" style="display: none;">
            <div class="card-header">
                <h4><i class="fas fa-flask me-2"></i>Модуль 3: Моделирование сценариев</h4>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-6">
                        <div class="config-section">
                            <h6>Параметры моделирования</h6>
                            <div class="mb-3">
                                <label class="form-label">Базовое поле для изменения</label>
                                <select class="form-select" id="simulationField">
                                    <option value="ads_cost">ads_cost</option>
                                </select>
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Период моделирования</label>
                                <input type="number" class="form-control" id="simulationPeriods" value="12" min="1" max="60">
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="config-section">
                            <h6>Сценарии</h6>
                            <div class="scenario-input">
                                <label class="form-label">Сценарий 1: Консервативный</label>
                                <input type="number" class="form-control" id="scenario1" value="10" step="5" placeholder="Изменение в %">
                            </div>
                            <div class="scenario-input">
                                <label class="form-label">Сценарий 2: Оптимистичный</label>
                                <input type="number" class="form-control" id="scenario2" value="30" step="5" placeholder="Изменение в %">
                            </div>
                            <div class="scenario-input">
                                <label class="form-label">Сценарий 3: Пессимистичный</label>
                                <input type="number" class="form-control" id="scenario3" value="-20" step="5" placeholder="Изменение в %">
                            </div>
                        </div>
                    </div>
                </div>
                <div class="text-center">
                    <button class="btn btn-warning btn-lg" onclick="runSimulation()">
                        <i class="fas fa-flask me-2"></i>Запустить моделирование
                    </button>
                </div>
                <div id="simulationResults" class="mt-4"></div>
            </div>
        </div>

        <!-- Результаты -->
        <div class="results-tabs" id="resultsSection" style="display: none;">
            <ul class="nav nav-tabs" id="resultsTabs" role="tablist">
                <li class="nav-item" role="presentation">
                    <button class="nav-link active" id="charts-tab" data-bs-toggle="tab" data-bs-target="#charts" type="button" role="tab">
                        <i class="fas fa-chart-bar me-2"></i>Графики
                    </button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="tables-tab" data-bs-toggle="tab" data-bs-target="#tables" type="button" role="tab">
                        <i class="fas fa-table me-2"></i>Таблицы
                    </button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="analysis-tab" data-bs-toggle="tab" data-bs-target="#analysis" type="button" role="tab">
                        <i class="fas fa-analytics me-2"></i>Анализ
                    </button>
                </li>
            </ul>
            <div class="tab-content" id="resultsTabContent">
                <div class="tab-pane fade show active" id="charts" role="tabpanel">
                    <div id="chartsContent"></div>
                </div>
                <div class="tab-pane fade" id="tables" role="tabpanel">
                    <div id="tablesContent"></div>
                </div>
                <div class="tab-pane fade" id="analysis" role="tabpanel">
                    <div id="analysisContent"></div>
                </div>
            </div>
        </div>

        <!-- Скачивание результатов -->
        <div class="download-section" id="downloadSection" style="display: none;">
            <h4><i class="fas fa-download me-2"></i>Скачать результаты</h4>
            <p>Ваш анализ готов! Вы можете скачать результаты в различных форматах.</p>
            <div class="row">
                <div class="col-md-4">
                    <button class="btn btn-success w-100" onclick="downloadCSV()">
                        <i class="fas fa-file-csv me-2"></i>Скачать CSV
                    </button>
                </div>
                <div class="col-md-4">
                    <button class="btn btn-primary w-100" onclick="downloadExcel()">
                        <i class="fas fa-file-excel me-2"></i>Скачать Excel
                    </button>
                </div>
                <div class="col-md-4">
                    <button class="btn btn-info w-100" onclick="downloadReport()">
                        <i class="fas fa-file-pdf me-2"></i>Скачать отчет
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Подвал -->
    <footer class="bg-dark text-white text-center py-4">
        <div class="container">
            <p class="mb-0">&copy; 2024 MARFOR - Маркетинговый инструмент прогнозирования</p>
        </div>
    </footer>

    <!-- Модальное окно сохранения проекта -->
    <div class="modal fade" id="saveProjectModal" tabindex="-1" aria-labelledby="saveProjectModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="saveProjectModalLabel">
                        <i class="fas fa-save me-2"></i>Сохранить проект
                    </h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label for="projectName" class="form-label">Название проекта</label>
                        <input type="text" class="form-control" id="projectName" placeholder="Введите название проекта">
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Что будет сохранено:</label>
                        <ul class="list-unstyled">
                            <li><i class="fas fa-check text-success me-2"></i>Загруженные данные</li>
                            <li><i class="fas fa-check text-success me-2"></i>Настройки маппинга</li>
                            <li><i class="fas fa-check text-success me-2"></i>Обработанные данные</li>
                            <li><i class="fas fa-check text-success me-2"></i>Временные ряды и срезы</li>
                        </ul>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Отмена</button>
                    <button type="button" class="btn btn-primary" onclick="saveProject()">
                        <i class="fas fa-save me-2"></i>Сохранить
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="/static/breadcrumbs.js"></script>
    <script src="/static/pivot_table_system.js"></script>
    <script>
        let currentSessionId = null;
        let dataColumns = [];
        let currentModule = null;
        let currentResults = {};
        let currentChart = null; // Глобальная переменная для хранения текущего графика
        let isFirstLoad = true; // Флаг первой загрузки
        
        // Глобальная переменная для хранения состояния сводной таблицы
        let pivotState = {
            expandedLevels: new Set(),
            currentData: null,
            pivotMode: 'time-series', // 'time-series' или 'slices'
            currentPivotMode: 'time-series', // Текущий режим представления
            originalHierarchy: null // Сохраняем исходную иерархию для фильтров
        };

        // Обработка загрузки файла
        document.addEventListener('DOMContentLoaded', function() {
            const fileInput = document.getElementById('fileInput');
            const uploadArea = document.getElementById('uploadArea');
            
            if (fileInput) {
                fileInput.addEventListener('change', handleFileUpload);
            }
            
            if (uploadArea) {
                uploadArea.addEventListener('click', () => {
                    document.getElementById('fileInput').click();
                });
                uploadArea.addEventListener('dragover', handleDragOver);
                uploadArea.addEventListener('drop', handleDrop);
            }
        });

        function handleDragOver(e) {
            e.preventDefault();
            e.currentTarget.style.borderColor = '#764ba2';
        }

        function handleDrop(e) {
            e.preventDefault();
            e.currentTarget.style.borderColor = '#667eea';
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        }

        function handleFileUpload(e) {
            const file = e.target.files[0];
            if (file) {
                handleFile(file);
            }
        }

        function handleFile(file) {
            const projectName = document.getElementById('projectNameInput').value.trim();
            
            if (!projectName) {
                showError('uploadStatus', 'Введите название проекта');
                return;
            }
            
            const formData = new FormData();
            formData.append('file', file);

            showLoading('uploadStatus', 'Загрузка файла и создание проекта...');

            fetch('/upload', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    currentSessionId = data.session_id;
                    dataColumns = data.data_info.columns;
                    
                    // Сохраняем данные в sessionStorage для маппинга
                    sessionStorage.setItem('sessionId', currentSessionId);
                    sessionStorage.setItem('uploadedData', JSON.stringify(data.data_info));
                    
                    // Автоматически создаем проект
                    createProject(projectName, data.data_info);
                } else {
                    showError('uploadStatus', data.message);
                }
            })
            .catch(error => {
                showError('uploadStatus', 'Ошибка при загрузке файла: ' + error.message);
            });
        }

        function createProject(projectName, dataInfo) {
            const saveData = {
                name: projectName,
                session_id: currentSessionId,
                data_mapping: {},
                processed_data: dataInfo
            };
            
            fetch('/api/save_project', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(saveData)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showSuccess('uploadStatus', `Проект "${projectName}" создан успешно!`);
                    showDataPreview(dataInfo);
                    populateFieldSelects();
                    showMappingButton();
                    
                    // Сохраняем ID проекта
                    sessionStorage.setItem('currentProjectId', data.project_id);
                } else {
                    showError('uploadStatus', 'Ошибка при создании проекта: ' + data.message);
                }
            })
            .catch(error => {
                showError('uploadStatus', 'Ошибка при создании проекта: ' + error.message);
            });
        }

        function showDataPreview(dataInfo, projectName = null) {
            const preview = document.getElementById('dataPreview');
            const projectTitle = projectName ? `<h4><i class="fas fa-folder me-2"></i>Проект: ${projectName}</h4>` : '';
            
            preview.innerHTML = `
                ${projectTitle}
                <div class="alert alert-info">
                    <h6><i class="fas fa-info-circle me-2"></i>Информация о данных</h6>
                    <p><strong>Размер:</strong> ${dataInfo.shape[0]} строк, ${dataInfo.shape[1]} колонок</p>
                    <p><strong>Колонки:</strong> ${dataInfo.columns.join(', ')}</p>
                </div>
                <div class="mt-3">
                    <button class="btn btn-primary btn-sm" onclick="showDataTable()">
                        <i class="fas fa-table me-2"></i>Показать превью данных (первые 50 строк)
                    </button>
                </div>
                <div id="dataTableContainer" class="mt-3" style="display: none;">
                    <div class="table-responsive" style="max-height: 400px; overflow-y: auto;">
                        <table class="table table-sm table-striped">
                            <thead id="dataTableHeader"></thead>
                            <tbody id="dataTableBody"></tbody>
                        </table>
                    </div>
                </div>
            `;
        }

        function showMappingButton() {
            const preview = document.getElementById('dataPreview');
            const mappingButton = document.createElement('div');
            mappingButton.className = 'text-center mt-3';
            mappingButton.innerHTML = `
                <button class="btn btn-primary btn-lg" onclick="goToMapping()">
                    <i class="fas fa-cogs me-2"></i>Настроить маппинг данных
                </button>
                <p class="text-muted mt-2">Настройте типы данных и обработку пустых значений</p>
            `;
            preview.appendChild(mappingButton);
        }

        function addNewProjectButton() {
            const preview = document.getElementById('dataPreview');
            const newProjectButton = document.createElement('div');
            newProjectButton.className = 'text-center mt-3';
            newProjectButton.innerHTML = `
                <button class="btn btn-outline-secondary btn-sm" onclick="createNewProject()">
                    <i class="fas fa-plus me-2"></i>Создать новый проект
                </button>
            `;
            preview.appendChild(newProjectButton);
        }

        function createNewProject() {
            // Очищаем sessionStorage
            sessionStorage.clear();
            
            // Показываем интерфейс создания нового проекта
            const uploadSection = document.getElementById('uploadSection');
            if (uploadSection) {
                uploadSection.style.display = 'block';
            }
            
            // Очищаем предпросмотр
            const preview = document.getElementById('dataPreview');
            preview.innerHTML = '';
            
            // Очищаем статус загрузки
            const uploadStatus = document.getElementById('uploadStatus');
            uploadStatus.innerHTML = '';
            
            // Очищаем глобальные переменные
            currentSessionId = null;
            dataColumns = [];
            processedData = null;
            dataMapping = null;
        }

        function goToMapping() {
            window.location.href = '/forecast/mapping';
        }

        // Глобальная переменная для сохранения выбранного среза
        let selectedSliceForSplit = '';
        
        // Флаг для предотвращения рекурсивных вызовов
        let isRenderingPivotTable = false;
        
        // Глобальная переменная для хранения текущих данных (новая система)
        let currentPivotData = null;

        // Функция для обновления таблицы с разбивкой по столбцам (новая система)
        function updatePivotTableWithSplit() {
            console.log('updatePivotTableWithSplit вызвана');
            
            // Получаем выбранное поле для разбивки в зависимости от режима
            let splitValue = '';
            const radioButtons = document.querySelectorAll('input[name="splitFieldSelection"]');
            radioButtons.forEach(radio => {
                if (radio.checked) {
                    splitValue = radio.value;
                }
            });
            
            console.log('Выбранное поле для разбивки:', splitValue);
            
            // Сохраняем выбранное значение в глобальную переменную
            if (pivotState.currentPivotMode === 'time-series') {
                window.selectedSlice = splitValue;
            } else {
                window.selectedTimeSeries = splitValue;
            }
            
            // Используем новую систему сводной таблицы
            if (currentPivotData) {
                console.log('Обновляем таблицу с новой системой');
                const mappingData = JSON.parse(sessionStorage.getItem('dataMapping') || '{}');
                // Добавляем выбранные поля в данные маппинга в зависимости от режима
                if (pivotState.currentPivotMode === 'time-series') {
                    if (window.selectedMetrics) {
                        mappingData.selectedMetrics = window.selectedMetrics;
                    }
                } else {
                    if (window.selectedSlices) {
                        mappingData.selectedSlices = window.selectedSlices;
                    }
                }
                
                const mode = splitValue ? 'split-columns' : 
                    (pivotState.currentPivotMode === 'time-series' ? 'time-series' : 'slices');
                renderNewPivotTable(currentPivotData, mappingData, mode, splitValue, pivotState.currentPivotMode);
            } else {
                console.log('Нет данных для отображения');
            }
        }

        function populateFieldSelects() {
            // Заполняем селекты для всех модулей
            const selects = [
                'trendTargetMetric', 'budgetField', 'simulationField'
            ];
            
            selects.forEach(selectId => {
                const select = document.getElementById(selectId);
                if (select) {
                    select.innerHTML = '';
                    dataColumns.forEach(col => {
                        const option = new Option(col, col);
                        select.add(option);
                    });
                }
            });

            // Заполняем список целевых метрик для анализа зависимостей
            const targetMetricsList = document.getElementById('targetMetricsList');
            targetMetricsList.innerHTML = '';
            dataColumns.forEach(col => {
                if (col.includes('traffic') || col.includes('revenue') || col.includes('transaction')) {
                    const div = document.createElement('div');
                    div.className = 'form-check';
                    div.innerHTML = `
                        <input class="form-check-input" type="checkbox" value="${col}" id="metric_${col}" checked>
                        <label class="form-check-label" for="metric_${col}">${col}</label>
                    `;
                    targetMetricsList.appendChild(div);
                }
            });
        }

        function showModule(moduleName) {
            if (!currentSessionId) {
                alert('Сначала загрузите данные!');
                return;
            }

            // Скрываем все модули
            document.getElementById('trendModule').style.display = 'none';
            document.getElementById('dependenciesModule').style.display = 'none';
            document.getElementById('simulationModule').style.display = 'none';

            // Показываем выбранный модуль
            currentModule = moduleName;
            document.getElementById(moduleName + 'Module').style.display = 'block';
        }

        function runTrendForecast() {
            const config = {
                target_metric: document.getElementById('trendTargetMetric').value,
                periods: parseInt(document.getElementById('trendPeriods').value),
                model: document.getElementById('trendModel').value,
                enable_cascade: document.getElementById('enableCascade').checked,
                cascade_level: document.getElementById('cascadeLevel').value
            };

            showLoading('trendResults', 'Выполнение трендового прогноза...');

            fetch('/trend_forecast', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(config)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    currentResults.trend = data;
                    showTrendResults(data);
                    showResultsSection();
                } else {
                    showError('trendResults', data.message);
                }
            })
            .catch(error => {
                showError('trendResults', 'Ошибка при выполнении прогноза: ' + error.message);
            });
        }

        function runDependencyAnalysis() {
            const targetMetrics = Array.from(document.querySelectorAll('#targetMetricsList input:checked')).map(cb => cb.value);
            const config = {
                budget_field: document.getElementById('budgetField').value,
                target_metrics: targetMetrics,
                method: document.getElementById('dependencyMethod').value,
                paid_channels: document.getElementById('paidChannels').value.split(',').map(s => s.trim()),
                organic_channels: document.getElementById('organicChannels').value.split(',').map(s => s.trim())
            };

            showLoading('dependenciesResults', 'Анализ зависимостей...');

            fetch('/dependency_analysis', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(config)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    currentResults.dependencies = data;
                    showDependencyResults(data);
                    showResultsSection();
                } else {
                    showError('dependenciesResults', data.message);
                }
            })
            .catch(error => {
                showError('dependenciesResults', 'Ошибка при анализе зависимостей: ' + error.message);
            });
        }

        function runSimulation() {
            const config = {
                simulation_field: document.getElementById('simulationField').value,
                periods: parseInt(document.getElementById('simulationPeriods').value),
                scenarios: [
                    { name: 'Консервативный', change: parseInt(document.getElementById('scenario1').value) },
                    { name: 'Оптимистичный', change: parseInt(document.getElementById('scenario2').value) },
                    { name: 'Пессимистичный', change: parseInt(document.getElementById('scenario3').value) }
                ]
            };

            showLoading('simulationResults', 'Моделирование сценариев...');

            fetch('/simulation', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(config)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    currentResults.simulation = data;
                    showSimulationResults(data);
                    showResultsSection();
                } else {
                    showError('simulationResults', data.message);
                }
            })
            .catch(error => {
                showError('simulationResults', 'Ошибка при моделировании: ' + error.message);
            });
        }

        function showTrendResults(data) {
            const container = document.getElementById('trendResults');
            let html = '<h6><i class="fas fa-chart-line me-2"></i>Результаты трендового прогноза</h6>';
            
            if (data.forecast_data) {
                html += `
                    <div class="row">
                        <div class="col-md-6">
                            <div class="metric-card">
                                <div class="metric-value">${data.forecast_data.total_forecast.toLocaleString()}</div>
                                <div>Общий прогноз</div>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="metric-card">
                                <div class="metric-value">${data.forecast_data.growth_rate.toFixed(1)}%</div>
                                <div>Темп роста</div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            container.innerHTML = html;
        }

        function showDependencyResults(data) {
            const container = document.getElementById('dependenciesResults');
            let html = '<h6><i class="fas fa-link me-2"></i>Результаты анализа зависимостей</h6>';
            
            if (data.dependencies) {
                html += '<div class="dependency-matrix">';
                html += '<table class="table table-striped">';
                html += '<thead><tr><th>Метрика</th><th>Корреляция с бюджетом</th><th>Сила влияния</th></tr></thead><tbody>';
                
                for (const [metric, info] of Object.entries(data.dependencies)) {
                    const strength = Math.abs(info.correlation) > 0.7 ? 'Сильная' : 
                                   Math.abs(info.correlation) > 0.3 ? 'Умеренная' : 'Слабая';
                    html += `<tr>
                        <td>${metric}</td>
                        <td>${info.correlation.toFixed(3)}</td>
                        <td><span class="badge ${Math.abs(info.correlation) > 0.7 ? 'bg-danger' : 
                                               Math.abs(info.correlation) > 0.3 ? 'bg-warning' : 'bg-secondary'}">${strength}</span></td>
                    </tr>`;
                }
                html += '</tbody></table></div>';
            }
            
            container.innerHTML = html;
        }

        function showSimulationResults(data) {
            const container = document.getElementById('simulationResults');
            let html = '<h6><i class="fas fa-flask me-2"></i>Результаты моделирования</h6>';
            
            if (data.scenarios) {
                html += '<div class="row">';
                for (const [scenarioName, result] of Object.entries(data.scenarios)) {
                    html += `
                        <div class="col-md-4">
                            <div class="card">
                                <div class="card-body text-center">
                                    <h6>${scenarioName}</h6>
                                    <div class="metric-value">${result.revenue_impact.toFixed(1)}%</div>
                                    <div>Влияние на выручку</div>
                                </div>
                            </div>
                        </div>
                    `;
                }
                html += '</div>';
            }
            
            container.innerHTML = html;
        }

        function showResultsSection() {
            document.getElementById('resultsSection').style.display = 'block';
            document.getElementById('downloadSection').style.display = 'block';
            updateResultsTabs();
        }

        function updateResultsTabs() {
            // Обновляем содержимое вкладок на основе текущих результатов
            updateChartsTab();
            updateTablesTab();
            updateAnalysisTab();
        }

        function updateChartsTab() {
            const container = document.getElementById('chartsContent');
            let html = '';
            
            if (currentResults.trend && currentResults.trend.chart_data) {
                html += '<div class="chart-container">';
                html += '<h6>График трендового прогноза</h6>';
                html += `<canvas id="trendChart"></canvas>`;
                html += '</div>';
            }
            
            if (currentResults.dependencies && currentResults.dependencies.chart_data) {
                html += '<div class="chart-container">';
                html += '<h6>Матрица зависимостей</h6>';
                html += `<canvas id="dependencyChart"></canvas>`;
                html += '</div>';
            }
            
            if (currentResults.simulation && currentResults.simulation.chart_data) {
                html += '<div class="chart-container">';
                html += '<h6>Сравнение сценариев</h6>';
                html += `<canvas id="simulationChart"></canvas>`;
                html += '</div>';
            }
            
            container.innerHTML = html;
            
            // Создаем графики
            createCharts();
        }

        function updateTablesTab() {
            const container = document.getElementById('tablesContent');
            let html = '';
            
            if (currentResults.trend && currentResults.trend.forecast_data) {
                html += '<div class="data-table">';
                html += '<h6>Данные трендового прогноза</h6>';
                html += '<div class="table-responsive">';
                html += '<table class="table table-striped">';
                html += '<thead><tr><th>Период</th><th>Прогноз</th><th>Доверительный интервал</th></tr></thead>';
                html += '<tbody>';
                
                currentResults.trend.forecast_data.periods.forEach(period => {
                    html += `<tr>
                        <td>${period.date}</td>
                        <td>${period.forecast.toLocaleString()}</td>
                        <td>${period.lower_bound.toLocaleString()} - ${period.upper_bound.toLocaleString()}</td>
                    </tr>`;
                });
                
                html += '</tbody></table></div></div>';
            }
            
            container.innerHTML = html;
        }

        function updateAnalysisTab() {
            const container = document.getElementById('analysisContent');
            let html = '<h6>Сводный анализ</h6>';
            
            if (currentResults.trend) {
                html += '<div class="alert alert-info">';
                html += '<h6>Трендовый прогноз</h6>';
                html += `<p>Модель: ${currentResults.trend.model_used}</p>`;
                html += `<p>Точность: ${currentResults.trend.accuracy.toFixed(3)}</p>`;
                html += '</div>';
            }
            
            if (currentResults.dependencies) {
                html += '<div class="alert alert-success">';
                html += '<h6>Анализ зависимостей</h6>';
                html += `<p>Найдено зависимостей: ${Object.keys(currentResults.dependencies.dependencies || {}).length}</p>`;
                html += '</div>';
            }
            
            if (currentResults.simulation) {
                html += '<div class="alert alert-warning">';
                html += '<h6>Моделирование</h6>';
                html += `<p>Проанализировано сценариев: ${Object.keys(currentResults.simulation.scenarios || {}).length}</p>`;
                html += '</div>';
            }
            
            container.innerHTML = html;
        }

        function createCharts() {
            // Создаем графики с помощью Chart.js
            if (currentResults.trend && currentResults.trend.chart_data) {
                const ctx = document.getElementById('trendChart');
                if (ctx) {
                    new Chart(ctx, {
                        type: 'line',
                        data: currentResults.trend.chart_data,
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            }
        }

        function downloadCSV() {
            if (currentSessionId) {
                window.open(`/download/csv/${currentSessionId}`, '_blank');
            }
        }

        function downloadExcel() {
            if (currentSessionId) {
                window.open(`/download/excel/${currentSessionId}`, '_blank');
            }
        }

        function downloadReport() {
            if (currentSessionId) {
                window.open(`/download/report/${currentSessionId}`, '_blank');
            }
        }

        // Вспомогательные функции
        function showLoading(elementId, message) {
            const element = document.getElementById(elementId);
            element.innerHTML = `<div class="loading"><div class="spinner-border text-primary" role="status"></div><p class="mt-2">${message}</p></div>`;
        }

        function showSuccess(elementId, message) {
            const element = document.getElementById(elementId);
            element.innerHTML = `<div class="alert alert-success"><i class="fas fa-check me-2"></i>${message}</div>`;
        }

        function showError(elementId, message) {
            const element = document.getElementById(elementId);
            element.innerHTML = `<div class="alert alert-danger"><i class="fas fa-exclamation-triangle me-2"></i>${message}</div>`;
        }

        // Глобальные переменные для обработанных данных
        let processedData = null;
        let dataMapping = null;

        // Загрузка результатов прогноза при загрузке страницы
        window.addEventListener('DOMContentLoaded', async function() {
            console.log('🔥🔥🔥 === СТРАНИЦА РЕЗУЛЬТАТОВ ПРОГНОЗА ЗАГРУЖЕНА ===');
            console.log('🔧 ВЕРСИЯ: Результаты прогноза v1.0.0');
            console.log('DOMContentLoaded вызван');
            console.log('📍 URL:', window.location.href);
            
            // Рендерим хлебные крошки (шаг 6 - Результаты прогноза)
            breadcrumbsModule.render(6);
            
            // Получаем session_id из URL
            const urlParams = new URLSearchParams(window.location.search);
            currentSessionId = urlParams.get('session_id') || sessionStorage.getItem('currentSessionId');
            
            console.log('🆔 session_id из URL:', urlParams.get('session_id'));
            console.log('🆔 session_id из sessionStorage:', sessionStorage.getItem('currentSessionId'));
            console.log('🆔 currentSessionId итоговый:', currentSessionId);
            
            if (!currentSessionId) {
                console.error('❌ Ошибка: session_id не найден!');
                alert('Ошибка: не указан session_id');
                window.location.href = '/';
                return;
            }
            
            console.log('📊 Загрузка результатов прогноза для сессии:', currentSessionId);
            
            // Скрываем секции, которые не нужны на странице результатов
            const uploadSection = document.getElementById('uploadSection');
            if (uploadSection) {
                uploadSection.style.display = 'none';
            }
            
            // Загружаем результаты прогноза
            await loadForecastResults();
        });
        
        async function loadForecastResults() {
            try {
                console.log('🔄 Загрузка результатов прогноза...');
                console.log('🔄 Запрос к API:', `/api/get_forecast_results/${currentSessionId}`);
                
                // Получаем результаты прогноза
                const response = await fetch(`/api/get_forecast_results/${currentSessionId}`);
                console.log('📡 Ответ сервера получен, status:', response.status);
                
                const result = await response.json();
                console.log('📦 Распарсен JSON:', result);
                
                if (!result.success) {
                    console.error('❌ API вернул ошибку:', result.message);
                    alert('Ошибка загрузки результатов: ' + result.message);
                    return;
                }
                
                console.log('✅ Результаты прогноза загружены');
                console.log('📊 Результаты:', result);
                
                // Сохраняем данные прогноза
                const forecastData = result.forecast_data;
                const forecastInfo = result.info;
                
                console.log('📊 forecastData:', forecastData);
                console.log('📊 forecastInfo:', forecastInfo);
                console.log('📊 Количество строк в raw_data:', forecastData.raw_data.length);
                
                // СНАЧАЛА загружаем маппинг
                const savedDataMapping = sessionStorage.getItem('dataMapping');
                if (!savedDataMapping) {
                    alert('Ошибка: маппинг не найден. Вернитесь к настройкам прогноза.');
                    return;
                }
                
                dataMapping = JSON.parse(savedDataMapping);
                console.log('📊 Маппинг загружен:', dataMapping);
                
                // ТЕПЕРЬ проверяем прогнозные данные
                const forecastRows = forecastData.raw_data.filter(row => row.is_forecast === true);
                const factRows = forecastData.raw_data.filter(row => row.is_forecast === false);
                console.log(`📊 Фактических строк: ${factRows.length}`);
                console.log(`📊 Прогнозных строк: ${forecastRows.length}`);
                console.log('📊 Пример прогнозной строки:', forecastRows[0]);
                
                // ВАЖНО: Проверяем значения всех метрик в прогнозных строках
                if (forecastRows.length > 0 && dataMapping && dataMapping.columns) {
                    console.log('🔍 === АНАЛИЗ ПРОГНОЗНЫХ ДАННЫХ ===');
                    const firstForecastRow = forecastRows[0];
                    const metrics = Object.keys(firstForecastRow).filter(key => 
                        dataMapping.columns.find(col => col.name === key && col.role === 'metric')
                    );
                    console.log('📊 Метрики в прогнозных строках:', metrics);
                    metrics.forEach(metric => {
                        const values = forecastRows.map(row => row[metric]);
                        console.log(`📊 ${metric}:`, values);
                    });
                }
                
                // Устанавливаем данные как processedData для совместимости
                processedData = {
                    data: forecastData.raw_data,
                    columns: Object.keys(forecastData.raw_data[0] || {}),
                    rows: forecastData.raw_data.length,
                    shape: [forecastData.raw_data.length, Object.keys(forecastData.raw_data[0] || {}).length]
                };
                
                // Устанавливаем глобальные переменные
                rawPivotData = forecastData.raw_data;
                dataColumns = processedData.columns;
                
                // Создаем dataInfo для совместимости
                const dataInfo = {
                    columns: dataColumns,
                    rows: processedData.rows,
                    sample_data: forecastData.raw_data.slice(0, 10)
                };
                
                // НЕ сохраняем в sessionStorage - данные слишком большие!
                // Храним только маппинг, session_id и метрику прогноза
                sessionStorage.setItem('forecastMetric', forecastInfo.metric);
                console.log('⚠️ Данные хранятся в памяти, не в sessionStorage (слишком большие)');
                
                // Показываем информацию о прогнозе (НЕ вызываем showProcessedDataPreview!)
                displayForecastInfo(forecastInfo);
                
                // Показываем интерфейс для работы с данными
                showForecastResultsInterface(processedData, dataMapping);
                
                console.log('✅ Интерфейс инициализирован');
                console.log('💡 Ожидаем автоматического выбора метрики и загрузки данных...');
                
            } catch (error) {
                console.error('❌ Ошибка загрузки результатов:', error);
                alert('Ошибка загрузки результатов прогноза: ' + error.message);
            }
        }
        
        function displayForecastInfo(info) {
            // Добавляем информационный блок о прогнозе
            const container = document.getElementById('dataPreview');
            if (!container) return;
            
            const infoHtml = `
                <div class="alert alert-success mb-3">
                    <h5><i class="fas fa-chart-line me-2"></i>Результаты прогноза</h5>
                    <div class="row">
                        <div class="col-md-3">
                            <strong>Модель:</strong> ${getModelDisplayName(info.model)}
                        </div>
                        <div class="col-md-3">
                            <strong>Метрика:</strong> ${info.metric}
                        </div>
                        <div class="col-md-3">
                            <strong>Фактических периодов:</strong> ${info.historical_periods}
                        </div>
                        <div class="col-md-3">
                            <strong>Прогнозных периодов:</strong> 
                            <span class="badge bg-warning text-dark">${info.forecast_periods}</span>
                        </div>
                    </div>
                    <hr>
                    <p class="mb-0">
                        <i class="fas fa-info-circle me-2"></i>
                        <strong>Прогнозные данные выделены желтым цветом</strong> (колонка is_forecast = True)
                    </p>
                </div>
            `;
            
            container.innerHTML = infoHtml;
        }
        
        function showForecastResultsInterface(processedData, mapping) {
            // Показываем интерфейс временных рядов для работы с прогнозными данными
            const container = document.getElementById('dataPreview');
            if (!container) return;
            
            // Добавляем интерфейс временных рядов после информации о прогнозе
            const interfaceHtml = `
                <div class="card mb-4">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h6 class="mb-0" id="pivotModeTitle">
                            <i class="fas fa-clock me-2"></i>Режим отображения: Временные ряды
                        </h6>
                        <div class="btn-group" role="group">
                            <button type="button" class="btn btn-sm btn-outline-secondary active" id="timeSeriesModeBtn" onclick="switchPivotMode('time-series')">
                                <i class="fas fa-clock me-1"></i>Временные ряды
                            </button>
                            <button type="button" class="btn btn-sm btn-outline-secondary" id="slicesModeBtn" onclick="switchPivotMode('slices')">
                                <i class="fas fa-layer-group me-1"></i>Срезы
                            </button>
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="row mb-3">
                            <div class="col-md-6">
                                <label class="form-label" id="primaryFieldLabel">Метрики</label>
                                <div class="dropdown">
                                    <button class="btn btn-outline-secondary dropdown-toggle w-100" type="button" id="primaryFieldDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                                        <span id="primaryFieldDropdownText">Выберите метрики</span>
                                    </button>
                                    <ul class="dropdown-menu w-100" id="primaryFieldDropdownMenu">
                                        <li class="dropdown-item-text">
                                            <div class="form-check">
                                                <input class="form-check-input" type="checkbox" id="selectAllPrimary" onchange="toggleAllPrimaryFields(this)">
                                                <label class="form-check-label fw-bold" for="selectAllPrimary">
                                                    Выбрать все
                                                </label>
                                            </div>
                                        </li>
                                        <li><hr class="dropdown-divider"></li>
                                        <div id="primaryFieldCheckboxes">
                                            <!-- Чекбоксы будут добавлены динамически -->
                                        </div>
                                    </ul>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <label class="form-label" id="splitFieldLabel">Разбивка по срезам</label>
                                <div class="dropdown">
                                    <button class="btn btn-outline-secondary dropdown-toggle w-100" type="button" id="splitFieldDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                                        <span id="splitFieldDropdownText">Только временные ряды</span>
                                    </button>
                                    <ul class="dropdown-menu w-100" id="splitFieldDropdownMenu">
                                        <li class="dropdown-item-text">
                                            <div class="form-check">
                                                <input class="form-check-input" type="radio" name="splitFieldSelection" id="noSplitFieldSelection" value="" onchange="updateSelectedSplitField()" checked>
                                                <label class="form-check-label fw-bold" for="noSplitFieldSelection">
                                                    <span id="noSplitFieldText">Только временные ряды</span>
                                                </label>
                                            </div>
                                        </li>
                                        <li><hr class="dropdown-divider"></li>
                                        <div id="splitFieldRadioButtons">
                                            <!-- Радиокнопки будут добавлены динамически -->
                                        </div>
                                    </ul>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Секция фильтров -->
                        <div class="row mb-3">
                            <div class="col-md-12">
                                <div class="card">
                                    <div class="card-header d-flex justify-content-between align-items-center">
                                        <h6 class="mb-0">
                                            <i class="fas fa-filter me-2"></i>Фильтры
                                        </h6>
                                        <button class="btn btn-sm btn-outline-secondary" onclick="resetAllFilters()">
                                            <i class="fas fa-undo me-1"></i>Сбросить все
                                        </button>
                                    </div>
                                    <div class="card-body">
                                        <div id="filtersContainer">
                                            <!-- Фильтры будут добавлены динамически -->
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="text-center">
                            <button class="btn btn-primary" id="buildChartBtn" onclick="loadForecastData();">
                                <i class="fas fa-chart-line me-2"></i>Обновить график
                            </button>
                            <p class="text-muted small mt-2">
                                <i class="fas fa-info-circle me-1"></i>
                                Изменения метрик, фильтров и разбивки применяются автоматически при нажатии кнопки
                            </p>
                        </div>
                        <div class="mt-3">
                            <div id="timeSeriesChartContainer">
                                <!-- График и таблица будут отрисованы здесь -->
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            container.insertAdjacentHTML('beforeend', interfaceHtml);
            
            // Инициализируем интерфейс
            setTimeout(() => {
                // Сначала сохраняем метрику прогноза (должна быть уже в sessionStorage)
                const forecastMetric = sessionStorage.getItem('forecastMetric');
                console.log('🎯 Метрика прогноза из sessionStorage:', forecastMetric);
                
                // Затем заполняем селекты
                populateTimeSeriesSelects();
                
                // Ждем рендеринга DOM и выбираем метрику
                setTimeout(() => {
                    if (forecastMetric) {
                        console.log('🎯 Автоматически выбираем метрику прогноза:', forecastMetric);
                        
                        // Снимаем все чекбоксы
                        const allCheckboxes = document.querySelectorAll('#primaryFieldCheckboxes input[type="checkbox"]');
                        allCheckboxes.forEach(cb => cb.checked = false);
                        
                        // Ищем чекбокс метрики прогноза
                        const checkbox = document.querySelector(`#primaryFieldCheckboxes input[value="${forecastMetric}"]`);
                        console.log('🎯 Найден чекбокс:', checkbox);
                        
                        if (checkbox) {
                            checkbox.checked = true;
                            updateSelectedMetrics();
                            console.log('✅ Метрика выбрана:', forecastMetric);
                            
                            // АВТОМАТИЧЕСКИ загружаем данные ТОЛЬКО при первой загрузке
                            if (isFirstLoad) {
                                setTimeout(() => {
                                    console.log('🚀 Автоматическая загрузка данных прогноза (первый раз)...');
                                    loadForecastData();
                                    isFirstLoad = false; // Отмечаем, что первая загрузка выполнена
                                }, 300);
                            } else {
                                console.log('💡 Метрика выбрана. Нажмите "Обновить график" для применения изменений.');
                            }
                        } else {
                            console.error('❌ Чекбокс не найден для метрики:', forecastMetric);
                        }
                    }
                }, 200);
            }, 100);
        }
        
        function getModelDisplayName(modelName) {
            const names = {
                'arima': 'ARIMA',
                'prophet': 'Prophet',
                'random_forest': 'Random Forest'
            };
            return names[modelName] || modelName;
        }
        
        function loadForecastData() {
            console.log('🚀 === ФУНКЦИЯ loadForecastData() ВЫЗВАНА ===');
            console.log('📊 rawPivotData:', rawPivotData ? rawPivotData.length : 'не определено');
            console.log('📊 dataMapping:', dataMapping);
            console.log('📊 window.selectedMetrics:', window.selectedMetrics);
            console.log('📊 pivotState.selectedMetrics:', pivotState.selectedMetrics);
            
            if (!rawPivotData || !dataMapping) {
                console.error('❌ Нет данных для отображения');
                return;
            }
            
            // Проверяем наличие прогнозных данных
            const forecastRows = rawPivotData.filter(row => row.is_forecast === true);
            const factRows = rawPivotData.filter(row => row.is_forecast === false);
            console.log(`📊 Отображаем: ${factRows.length} фактических + ${forecastRows.length} прогнозных строк`);
            
            // Проверяем наличие выбранных полей в зависимости от режима
            const mode = pivotState.currentPivotMode || 'time-series';
            
            if (mode === 'time-series') {
                // Режим временных рядов - проверяем метрики
                if (!window.selectedMetrics || window.selectedMetrics.length === 0) {
                    console.warn('⚠️ window.selectedMetrics пуст, пытаемся взять из чекбоксов');
                    const selectedCheckboxes = document.querySelectorAll('#primaryFieldCheckboxes input[type="checkbox"]:checked');
                    if (selectedCheckboxes.length > 0) {
                        window.selectedMetrics = Array.from(selectedCheckboxes).map(cb => cb.value);
                        console.log('✅ Установлены метрики из чекбоксов:', window.selectedMetrics);
                    } else {
                        alert('Выберите хотя бы одну метрику');
                        return;
                    }
                }
            } else {
                // Режим срезов - проверяем срезы
                if (!window.selectedSlices || window.selectedSlices.length === 0) {
                    console.warn('⚠️ window.selectedSlices пуст, пытаемся взять из чекбоксов');
                    const selectedCheckboxes = document.querySelectorAll('#primaryFieldCheckboxes input[type="checkbox"]:checked');
                    if (selectedCheckboxes.length > 0) {
                        window.selectedSlices = Array.from(selectedCheckboxes).map(cb => cb.value);
                        console.log('✅ Установлены срезы из чекбоксов:', window.selectedSlices);
                    } else {
                        alert('Выберите хотя бы один срез');
                        return;
                    }
                }
            }
            
            // Получаем выбранные метрики/срезы
            const selectedMetrics = window.selectedMetrics || pivotState.selectedMetrics || [];
            const selectedSlices = window.selectedSlices || [];
            console.log('📊 Выбранные поля для отображения:', mode === 'time-series' ? selectedMetrics : selectedSlices);
            
            // Создаем копию маппинга и включаем только выбранные поля
            const modifiedMapping = JSON.parse(JSON.stringify(dataMapping));
            
            if (mode === 'time-series') {
                // Режим временных рядов - фильтруем метрики
                let includedMetrics = [];
                modifiedMapping.columns.forEach(col => {
                    if (col.role === 'metric') {
                        col.include = selectedMetrics.includes(col.name);
                        if (col.include) {
                            includedMetrics.push(col.name);
                        }
                        console.log(`📊 Метрика ${col.name}: include = ${col.include}`);
                    }
                });
                modifiedMapping.selectedMetrics = selectedMetrics;
                console.log('✅ Метрики для отображения:', includedMetrics);
            } else {
                // Режим срезов - передаем selectedSlices
                modifiedMapping.selectedSlices = selectedSlices;
                console.log('✅ Срезы для отображения:', selectedSlices);
            }
            
            // Используем напрямую renderNewPivotTable с данными из памяти
            const mode = pivotState.currentPivotMode || 'time-series';
            const splitField = selectedSliceForSplit || '';
            
            console.log('🎨 Рендерим сводную таблицу:', {
                mode: mode,
                splitField: splitField,
                dataRows: rawPivotData.length,
                selectedMetrics: selectedMetrics
            });
            
            // ВАЖНО: Очищаем контейнер и уничтожаем старый график
            const container = document.getElementById('timeSeriesChartContainer');
            if (container) {
                console.log('🧹 Очищаем контейнер перед рендерингом');
                
                // Уничтожаем старый график Chart.js если он существует
                const oldCanvas = container.querySelector('#pivotChart');
                if (oldCanvas) {
                    const chartInstance = Chart.getChart(oldCanvas);
                    if (chartInstance) {
                        console.log('🗑️ Уничтожаем старый экземпляр графика');
                        chartInstance.destroy();
                    }
                }
                
                // Очищаем весь контейнер
                container.innerHTML = '<div class="text-center"><div class="spinner-border text-primary" role="status"></div><p class="mt-2">Обновление данных...</p></div>';
            }
            
            // Небольшая задержка для визуального эффекта
            setTimeout(() => {
                if (typeof renderNewPivotTable === 'function') {
                    console.log('🎨 Вызываем renderNewPivotTable с параметрами:');
                    console.log('   - Данные:', rawPivotData.length, 'строк');
                    console.log('   - Режим:', mode);
                    console.log('   - Разбивка:', splitField);
                    console.log('   - Метрики в маппинге (include=true):', 
                        modifiedMapping.columns.filter(c => c.role === 'metric' && c.include).map(c => c.name)
                    );
                    
                    const result = renderNewPivotTable(rawPivotData, modifiedMapping, mode, splitField);
                    
                    console.log('✅ renderNewPivotTable вернула:', result);
                    console.log('✅ Сводная таблица отрисована');
                    
                    // Проверяем, создался ли новый график
                    setTimeout(() => {
                        const newCanvas = document.querySelector('#pivotChart');
                        if (newCanvas) {
                            const newChartInstance = Chart.getChart(newCanvas);
                            console.log('✅ Новый график создан:', !!newChartInstance);
                            if (newChartInstance) {
                                console.log('📊 Датасеты в графике:', newChartInstance.data.datasets.map(d => d.label));
                            }
                        } else {
                            console.error('❌ Canvas #pivotChart не найден после рендеринга!');
                        }
                    }, 500);
                } else {
                    console.error('❌ Функция renderNewPivotTable не найдена!');
                }
            }, 100);
        }

        async function loadProjectFromUrl(projectId) {
            console.log('loadProjectFromUrl вызвана с projectId:', projectId);
            
            try {
                // Загружаем данные проекта через API
                const projectResponse = await fetch(`/api/load_project/${projectId}`);
                const projectData = await projectResponse.json();
                
                console.log('Ответ от сервера:', projectData);
                
                if (!projectData.success) {
                    alert('Ошибка при загрузке проекта: ' + projectData.message);
                    return;
                }
                
                const project = projectData.project;
                currentSessionId = project.session_id;
                
                // Получаем data_info отдельно через API
                const dataInfoResponse = await fetch(`/api/get_processed_data/${currentSessionId}`);
                const dataInfoData = await dataInfoResponse.json();
                
                if (!dataInfoData.success) {
                    alert('Ошибка при получении данных: ' + dataInfoData.message);
                    return;
                }
                
                console.log('Проект успешно загружен:', project);
                console.log('Данные получены:', dataInfoData.data_info);
                
                // Сохраняем данные в sessionStorage
                sessionStorage.setItem('sessionId', currentSessionId);
                sessionStorage.setItem('currentProjectId', project.id);
                
                // Сохраняем data_info без full_data
                const dataInfoForStorage = { ...dataInfoData.data_info };
                delete dataInfoForStorage.full_data;
                
                // Безопасное сохранение в sessionStorage
                try {
                    sessionStorage.setItem('dataInfo', JSON.stringify(dataInfoForStorage));
                    sessionStorage.setItem('uploadedData', JSON.stringify(dataInfoForStorage));
                    if (project.mapping_config) {
                        sessionStorage.setItem('dataMapping', JSON.stringify(project.mapping_config));
                    }
                } catch (error) {
                    console.warn('Ошибка сохранения в sessionStorage:', error);
                    sessionStorage.clear();
                    sessionStorage.setItem('sessionId', currentSessionId);
                    sessionStorage.setItem('dataInfo', JSON.stringify(dataInfoForStorage));
                    sessionStorage.setItem('currentProjectId', project.id);
                }
                
                // Устанавливаем глобальные переменные
                dataInfo = dataInfoData.data_info;
                dataColumns = dataInfo.columns;
                dataMapping = project.mapping_config || {};
                processedData = null; // Будет получено после применения маппинга
                
                // Скрываем интерфейс создания нового проекта
                const uploadSection = document.getElementById('uploadSection');
                if (uploadSection) {
                    uploadSection.style.display = 'none';
                }
                
                // Показываем информацию о загруженном проекте
                showDataPreview(dataInfo, project.name);
                populateFieldSelects();
                populateTimeSeriesSelects();
                
                // Добавляем кнопку для создания нового проекта
                addNewProjectButton();
                
                // Всегда переходим на страницу маппинга
                window.location.href = '/forecast/mapping';
                
            } catch (error) {
                console.error('Ошибка при загрузке проекта:', error);
                alert('Ошибка при загрузке проекта: ' + error.message);
                window.location.href = '/';
            }
        }

        function showProcessedDataPreview(processedData, mapping) {
            const preview = document.getElementById('dataPreview');
            preview.innerHTML = `
                <div class="alert alert-success">
                    <div class="d-flex justify-content-between align-items-center">
                        <div>
                            <h6 class="mb-1"><i class="fas fa-check-circle me-2"></i>Данные обработаны и готовы к прогнозированию</h6>
                            <p class="mb-0"><strong>Размер:</strong> ${processedData.shape[0]} строк, ${processedData.shape[1]} колонок</p>
                </div>
                        <button class="btn btn-outline-success btn-sm" type="button" data-bs-toggle="collapse" data-bs-target="#dataDetails" aria-expanded="false" aria-controls="dataDetails">
                            <i class="fas fa-chevron-down me-1"></i>Подробнее
                        </button>
                    </div>
                    <div class="collapse mt-3" id="dataDetails">
                        <hr>
                        <p><strong>Колонки:</strong> ${processedData.columns.join(', ')}</p>
                        <div class="row">
                    <div class="col-md-6">
                        <h6><i class="fas fa-clock me-2"></i>Временные ряды</h6>
                        <ul class="list-unstyled">
                            ${getTimeSeriesInfo(mapping)}
                        </ul>
                    </div>
                    <div class="col-md-6">
                        <h6><i class="fas fa-layer-group me-2"></i>Срезы</h6>
                        <ul class="list-unstyled">
                            ${getSlicesInfo(mapping)}
                        </ul>
                    </div>
                </div>
                    <div class="col-md-12">
                        <h6><i class="fas fa-cogs me-2"></i>Правила обработки данных</h6>
                        <ul class="list-unstyled">
                            <li><strong>Обработка пропусков:</strong> ${mapping.missingValues || 'Не указано'}</li>
                            <li><strong>Обнаружение выбросов:</strong> ${mapping.detectOutliers ? 'Включено' : 'Отключено'}</li>
                            <li><strong>Нормализация:</strong> ${mapping.normalizeData ? 'Включена' : 'Отключена'}</li>
                            <li><strong>Логарифмическое преобразование:</strong> ${mapping.logTransform ? 'Включено' : 'Отключено'}</li>
                            <li><strong>Создание признаков:</strong> ${mapping.createFeatures ? 'Включено' : 'Отключено'}</li>
                        </ul>
                    </div>
                </div>
                <div class="mt-3">
                    <button class="btn btn-info btn-sm" onclick="showDataTable()">
                        <i class="fas fa-table me-2"></i>Показать таблицу данных
                    </button>
                    <button class="btn btn-warning btn-sm ms-2" onclick="editMapping()">
                        <i class="fas fa-edit me-2"></i>Изменить маппинг
                    </button>
                    <button class="btn btn-primary btn-sm ms-2" onclick="showSaveProjectModal()">
                        <i class="fas fa-save me-2"></i>Сохранить проект
                    </button>
                    <button class="btn btn-danger btn-sm ms-2" onclick="deleteCurrentProject()">
                        <i class="fas fa-trash me-2"></i>Удалить проект
                    </button>
                    <button class="btn btn-success btn-sm ms-2" onclick="goToForecastSettings()">
                        <i class="fas fa-cog me-2"></i>Перейти к настройке параметров для прогноза
                    </button>
                </div>
                <div id="dataTableContainer" class="mt-3" style="display: none;">
                    <div class="table-responsive" style="max-height: 400px; overflow-y: auto;">
                        <table class="table table-sm table-striped">
                            <thead id="dataTableHeader"></thead>
                            <tbody id="dataTableBody"></tbody>
                        </table>
                    </div>
                </div>
                <div id="timeSeriesContainer" class="mt-3" style="display: block;">
                    <div class="card">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <h6 class="mb-0">
                                <i class="fas fa-chart-line me-2"></i>
                                <span id="pivotModeTitle">Временные ряды</span>
                            </h6>
                            <div class="btn-group" role="group">
                                <button type="button" class="btn btn-sm btn-outline-secondary active" id="timeSeriesModeBtn" onclick="switchPivotMode('time-series')">
                                    <i class="fas fa-clock me-1"></i>Временные ряды
                                </button>
                                <button type="button" class="btn btn-sm btn-outline-secondary" id="slicesModeBtn" onclick="switchPivotMode('slices')">
                                    <i class="fas fa-layer-group me-1"></i>Срезы
                                </button>
                            </div>
                        </div>
                        <div class="card-body">
                            <div class="row mb-3">
                                <div class="col-md-6">
                                    <label class="form-label" id="primaryFieldLabel">Метрики</label>
                                    <div class="dropdown">
                                        <button class="btn btn-outline-secondary dropdown-toggle w-100" type="button" id="primaryFieldDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                                            <span id="primaryFieldDropdownText">Выберите метрики</span>
                                        </button>
                                        <ul class="dropdown-menu w-100" id="primaryFieldDropdownMenu">
                                            <li class="dropdown-item-text">
                                                <div class="form-check">
                                                    <input class="form-check-input" type="checkbox" id="selectAllPrimary" onchange="toggleAllPrimaryFields(this)">
                                                    <label class="form-check-label fw-bold" for="selectAllPrimary">
                                                        Выбрать все
                                                    </label>
                                                </div>
                                            </li>
                                            <li><hr class="dropdown-divider"></li>
                                            <div id="primaryFieldCheckboxes">
                                                <!-- Чекбоксы будут добавлены динамически -->
                                            </div>
                                        </ul>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <label class="form-label" id="splitFieldLabel">Разбивка по срезам</label>
                                    <div class="dropdown">
                                        <button class="btn btn-outline-secondary dropdown-toggle w-100" type="button" id="splitFieldDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                                            <span id="splitFieldDropdownText">Только временные ряды</span>
                                        </button>
                                        <ul class="dropdown-menu w-100" id="splitFieldDropdownMenu">
                                            <li class="dropdown-item-text">
                                                <div class="form-check">
                                                    <input class="form-check-input" type="radio" name="splitFieldSelection" id="noSplitFieldSelection" value="" onchange="updateSelectedSplitField()" checked>
                                                    <label class="form-check-label fw-bold" for="noSplitFieldSelection">
                                                        <span id="noSplitFieldText">Только временные ряды</span>
                                                    </label>
                                </div>
                                            </li>
                                            <li><hr class="dropdown-divider"></li>
                                            <div id="splitFieldRadioButtons">
                                                <!-- Радиокнопки будут добавлены динамически -->
                            </div>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Секция фильтров -->
                            <div class="row mb-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header d-flex justify-content-between align-items-center">
                                            <h6 class="mb-0">
                                                <i class="fas fa-filter me-2"></i>Фильтры
                                            </h6>
                                            <button class="btn btn-sm btn-outline-secondary" onclick="resetAllFilters()">
                                                <i class="fas fa-undo me-1"></i>Сбросить все
                                            </button>
                                        </div>
                                        <div class="card-body">
                                            <div id="filtersContainer">
                                                <!-- Фильтры будут добавлены динамически -->
                                                <p class="text-muted text-center">Выберите данные для отображения фильтров</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="text-center">
                                <button class="btn btn-primary" id="buildChartBtn" onclick="console.log('🔴 КНОПКА НАЖАТА через onclick!'); loadTimeSeriesData();">
                                    <i class="fas fa-chart-line me-2"></i>Построить график
                                </button>
                            </div>
                            <div class="mt-3">
                                <div id="timeSeriesChartContainer">
                                    <canvas id="timeSeriesChart" width="400" height="200"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Автоматически загружаем график с первой метрикой
            setTimeout(() => {
                populateTimeSeriesSelects();
                loadTimeSeriesData();
            }, 500);
        }

        function getTimeSeriesInfo(mapping) {
            if (!mapping || !mapping.columns) {
                return '<li>Не настроено</li>';
            }
            
            const info = [];
            const timeTypes = {
                'date': 'Дата',
                'year': 'Год', 
                'month': 'Месяц',
                'week': 'Неделя',
                'quarter': 'Квартал',
                'halfyear': 'Полугодие'
            };
            
            // Собираем временные ряды
            const timeSeriesCols = [];
            mapping.columns.forEach(col => {
                if (col.time_series && col.time_series !== '') {
                    const level = col.nesting_level || 0;
                    timeSeriesCols.push({
                        name: col.name,
                        type: col.time_series,
                        level: level
                    });
                }
            });
            
            // Сортируем по возрастанию уровней (0, 1, 2, 3...)
            timeSeriesCols.sort((a, b) => a.level - b.level);
            
            timeSeriesCols.forEach(col => {
                info.push(`<li><strong>${timeTypes[col.type]}:</strong> ${col.name} (уровень ${col.level})</li>`);
            });
            
            return info.length > 0 ? info.join('') : '<li>Не настроено</li>';
        }

        function getSlicesInfo(mapping) {
            if (!mapping || !mapping.columns) {
                return '<li>Не настроено</li>';
            }
            
            const info = [];
            const sliceCols = [];
            
            // Ищем колонки с ролью dimension и уровнями вложенности, исключая временные ряды
            mapping.columns.forEach(col => {
                if (col.role === 'dimension' && col.nesting_level >= 0 && !col.time_series) {
                    sliceCols.push({
                        name: col.name,
                        level: col.nesting_level
                    });
                }
            });
            
            // Сортируем по убыванию уровней
            sliceCols.sort((a, b) => b.level - a.level);
            
            sliceCols.forEach(col => {
                info.push(`<li><strong>Уровень ${col.level}:</strong> ${col.name}</li>`);
            });
            
            return info.length > 0 ? info.join('') : '<li>Не настроено</li>';
        }

        function showDataTable() {
            const container = document.getElementById('dataTableContainer');
            const header = document.getElementById('dataTableHeader');
            const body = document.getElementById('dataTableBody');
            
            if (container.style.display === 'none') {
                // Показываем таблицу
                header.innerHTML = '';
                body.innerHTML = '';
                
                // Заголовки
                processedData.columns.forEach(col => {
                    const th = document.createElement('th');
                    th.textContent = col;
                    header.appendChild(th);
                });
                
                // Данные (первые 50 строк)
                processedData.sample_data.slice(0, 50).forEach(row => {
                    const tr = document.createElement('tr');
                    processedData.columns.forEach(col => {
                        const td = document.createElement('td');
                        td.textContent = row[col] || '';
                        td.style.fontSize = '0.8em';
                        tr.appendChild(td);
                    });
                    body.appendChild(tr);
                });
                
                container.style.display = 'block';
            } else {
                // Скрываем таблицу
                container.style.display = 'none';
            }
        }

        function editMapping() {
            window.location.href = '/forecast/mapping';
        }

        function showTimeSeriesChart() {
            const container = document.getElementById('timeSeriesContainer');
            
            if (container.style.display === 'none') {
                // Показываем контейнер и заполняем селекты
                populateTimeSeriesSelects();
                container.style.display = 'block';
            } else {
                // Скрываем контейнер
                container.style.display = 'none';
            }
        }

        function populateTimeSeriesSelects() {
            console.log('🚀 populateTimeSeriesSelects() вызвана, режим:', pivotState.currentPivotMode);
            console.log('🚀 Вызов из стека:', new Error().stack);
            
            const primaryFieldCheckboxes = document.getElementById('primaryFieldCheckboxes');
            const primaryFieldDropdownText = document.getElementById('primaryFieldDropdownText');
            const splitFieldRadioButtons = document.getElementById('splitFieldRadioButtons');
            const splitFieldDropdownText = document.getElementById('splitFieldDropdownText');
            
            // Проверяем наличие элементов
            if (!primaryFieldCheckboxes) {
                console.error('Элемент чекбоксов основного поля не найден');
                return;
            }
            
            // Очищаем чекбоксы
            primaryFieldCheckboxes.innerHTML = '';
            splitFieldRadioButtons.innerHTML = '';
            
            let availablePrimaryFields = [];
            let availableSplitFields = [];
            
            if (!processedData) {
                console.log('processedData не найден, используем dataInfo');
                // Используем dataInfo если processedData недоступен
                const dataInfo = JSON.parse(sessionStorage.getItem('dataInfo') || '{}');
                if (dataInfo.columns) {
                    if (pivotState.currentPivotMode === 'time-series') {
                        availablePrimaryFields = getMetricsFromDataInfo(dataInfo);
                        availableSplitFields = getSlicesFromDataInfo(dataInfo);
                    } else {
                        availablePrimaryFields = getSlicesFromDataInfo(dataInfo);
                        availableSplitFields = getTimeSeriesFromDataInfo(dataInfo);
                    }
                }
            } else {
            // Получаем настройки маппинга
            const mappingConfig = JSON.parse(sessionStorage.getItem('dataMapping') || '{}');
            
                if (pivotState.currentPivotMode === 'time-series') {
                    // Режим "Временные ряды" - первичное поле = метрики, разбивка = срезы
            processedData.columns.forEach((col, index) => {
                // Метрики - только колонки с ролью "metric"
                const columnMapping = mappingConfig.columns?.find(c => c.name === col);
                if (columnMapping && columnMapping.role === 'metric') {
                            availablePrimaryFields.push(col);
                } else if (!mappingConfig.columns && processedData.dtypes[col] && 
                    (processedData.dtypes[col].includes('int') || processedData.dtypes[col].includes('float'))) {
                    // Fallback: если нет маппинга, используем числовые колонки
                            availablePrimaryFields.push(col);
                        }
                    });
                    
                    // Получаем срезы для разбивки
                    availableSplitFields = getSlicesFromDataInfo(processedData || {});
                } else {
                    // Режим "Срезы" - первичное поле = срезы (region_to, category, subdivision), разбивка = временные ряды
                    availablePrimaryFields = getSlicesFromDataInfo(processedData || {});
                    console.log('Режим slices - доступные срезы для основного поля:', availablePrimaryFields);
                    
                    // Получаем временные ряды для разбивки
                    availableSplitFields = getTimeSeriesFromDataInfo(processedData || {});
                    console.log('Режим slices - доступные временные ряды для разбивки:', availableSplitFields);
                }
            }
            
            // Создаем чекбоксы для основного поля
            if (pivotState.currentPivotMode === 'time-series') {
                // Режим временных рядов: основное поле = метрики
                createMetricsCheckboxes(availablePrimaryFields);
                // Выбираем первую метрику по умолчанию
                if (availablePrimaryFields.length > 0) {
                    selectFirstMetric(availablePrimaryFields[0]);
                }
            } else {
                // Режим срезов: основное поле = срезы
                createSlicesCheckboxes(availablePrimaryFields);
                // Выбираем первый срез по умолчанию
                if (availablePrimaryFields.length > 0) {
                    selectFirstSlice(availablePrimaryFields[0]);
                }
            }
            
            // Создаем радиокнопки для разбивки
            console.log('Создаем радиокнопки для разбивки:', {
                mode: pivotState.currentPivotMode,
                availableSplitFields: availableSplitFields,
                availableSplitFieldsLength: availableSplitFields.length
            });
            
            if (pivotState.currentPivotMode === 'time-series') {
                console.log('Вызываем createSlicesRadioButtons');
                createSlicesRadioButtons(availableSplitFields);
            } else {
                console.log('Вызываем createTimeSeriesRadioButtons');
                createTimeSeriesRadioButtons(availableSplitFields);
            }
            
            console.log('Доступные поля для разбивки:', availableSplitFields);
            
            // Восстанавливаем ранее выбранный срез
            if (selectedSliceForSplit) {
                const radioId = 'slice_' + selectedSliceForSplit.replace(/[^a-zA-Z0-9]/g, '_');
                const radio = document.getElementById(radioId);
                if (radio) {
                    radio.checked = true;
                    updateSelectedSlice();
                }
            }
            
            console.log('Дропбокс основного поля заполнен:', availablePrimaryFields);
        }

        // Функции для работы с фильтрами
        function populateFilters(rawData, mappingData) {
            console.log('=== populateFilters ВЫЗВАНА ===');
            console.log('rawData:', rawData?.length, 'строк');
            console.log('mappingData:', mappingData?.columns?.length, 'колонок');
            console.log('Полные данные:', { rawData, mappingData });
            
            // Проверяем, что класс PivotFilter доступен
            if (typeof PivotFilter === 'undefined') {
                console.error('Класс PivotFilter не определен! Проверьте загрузку static/pivot_table_system.js');
                return;
            }
            
            const filtersContainer = document.getElementById('filtersContainer');
            if (!filtersContainer) {
                console.error('Контейнер filtersContainer не найден!');
                return;
            }
            
            // Очищаем контейнер
            filtersContainer.innerHTML = '';
            
            if (!rawData || !mappingData || !mappingData.columns) {
                console.log('Нет данных для создания фильтров:', { rawData: !!rawData, mappingData: !!mappingData, columns: mappingData?.columns?.length });
                filtersContainer.innerHTML = '<p class="text-muted text-center">Выберите данные для отображения фильтров</p>';
                return;
            }
            
            // Создаем фильтры для временных полей и срезов
            const filters = [];
            console.log('Создаем фильтры из колонок:', mappingData.columns.length);
            
            mappingData.columns.forEach(col => {
                console.log('Обрабатываем колонку:', { name: col.name, role: col.role, include: col.include, type: col.type });
                
                if (col.role === 'dimension' && col.include) {
                    let fieldType = 'text';
                    if (col.type === 'numeric') {
                        fieldType = 'number';
                    } else if (col.type === 'date') {
                        fieldType = 'date';
                    }
                    
                    console.log('Создаем фильтр для:', col.name, 'тип:', fieldType);
                    
                    const filter = new PivotFilter(col.name, fieldType, col.name);
                    filter.getAvailableValues(rawData);
                    filters.push(filter);
                    
                    console.log('Фильтр создан:', { 
                        name: filter.fieldName, 
                        type: filter.fieldType, 
                        valuesCount: filter.availableValues.length,
                        firstValues: filter.availableValues.slice(0, 5)
                    });
                }
            });
            
            console.log('Создано фильтров:', filters.length);
            
            if (filters.length === 0) {
                console.log('Нет доступных фильтров для отображения');
                filtersContainer.innerHTML = '<p class="text-muted text-center">Нет доступных фильтров</p>';
                return;
            }
            
            // Создаем HTML для каждого фильтра
            filters.forEach((filter, index) => {
                console.log(`Создаем HTML для фильтра ${index + 1}:`, filter.fieldName);
                const filterHTML = createFilterHTML(filter);
                filtersContainer.appendChild(filterHTML);
            });
            
            // Сохраняем фильтры для использования
            window.currentFilters = filters;
            console.log('Фильтры сохранены в window.currentFilters:', filters.length);
        }
        
        function createFilterHTML(filter) {
            console.log('createFilterHTML для фильтра:', filter.fieldName, 'тип:', filter.fieldType);
            
            const div = document.createElement('div');
            div.className = 'filter-card';
            div.id = `filter-${filter.fieldName}`;
            
            let bodyHTML = '';
            if (filter.fieldType === 'text') {
                bodyHTML = createTextFilterHTML(filter);
                console.log('Создан HTML для текстового фильтра:', bodyHTML.length, 'символов');
            } else if (filter.fieldType === 'number') {
                bodyHTML = createNumberFilterHTML(filter);
                console.log('Создан HTML для числового фильтра:', bodyHTML.length, 'символов');
            }
            
            div.innerHTML = `
                <div class="filter-header filter-toggle" onclick="toggleFilter('${filter.fieldName}')">
                    <i class="fas fa-chevron-down me-2"></i>${filter.fieldLabel}
                    <span class="badge bg-secondary ms-2" id="filter-count-${filter.fieldName}">${filter.availableValues.length}</span>
                </div>
                <div class="filter-body" id="filter-body-${filter.fieldName}" style="display: none;">
                    ${bodyHTML}
                </div>
            `;
            
            return div;
        }
        
        function createTextFilterHTML(filter) {
            const checkboxes = filter.availableValues.map(value => `
                <div class="filter-checkbox-item">
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" value="${value}" 
                               id="filter-${filter.fieldName}-${value}" 
                               onchange="updateTextFilter('${filter.fieldName}')">
                        <label class="form-check-label" for="filter-${filter.fieldName}-${value}">
                            ${value}
                        </label>
                    </div>
                </div>
            `).join('');
            
            return `
                <div class="filter-checkbox-list">
                    ${checkboxes}
                </div>
                <div class="mt-2">
                    <button class="btn btn-sm btn-outline-primary me-2" onclick="selectAllFilterValues('${filter.fieldName}')">
                        Выбрать все
                    </button>
                    <button class="btn btn-sm btn-outline-secondary" onclick="clearFilterValues('${filter.fieldName}')">
                        Очистить
                    </button>
                </div>
            `;
        }
        
        function createNumberFilterHTML(filter) {
            return `
                <div class="filter-slider-container">
                    <div class="filter-slider-label">От: <span id="filter-${filter.fieldName}-min-label">${filter.minValue}</span></div>
                    <input type="range" class="form-range" 
                           id="filter-${filter.fieldName}-min" 
                           min="${filter.minValue}" max="${filter.maxValue}" 
                           value="${filter.minValue}"
                           oninput="updateNumberFilter('${filter.fieldName}')">
                    
                    <div class="filter-slider-label">До: <span id="filter-${filter.fieldName}-max-label">${filter.maxValue}</span></div>
                    <input type="range" class="form-range" 
                           id="filter-${filter.fieldName}-max" 
                           min="${filter.minValue}" max="${filter.maxValue}" 
                           value="${filter.maxValue}"
                           oninput="updateNumberFilter('${filter.fieldName}')">
                    
                    <div class="filter-slider-value" id="filter-${filter.fieldName}-range">
                        ${filter.minValue} - ${filter.maxValue}
                    </div>
                </div>
            `;
        }
        
        function toggleFilter(filterName) {
            const body = document.getElementById(`filter-body-${filterName}`);
            const icon = document.querySelector(`#filter-${filterName} .fa-chevron-down`);
            
            if (body.style.display === 'none') {
                body.style.display = 'block';
                icon.className = 'fas fa-chevron-up me-2';
                    } else {
                body.style.display = 'none';
                icon.className = 'fas fa-chevron-down me-2';
            }
        }
        
        function updateTextFilter(filterName) {
            const checkboxes = document.querySelectorAll(`#filter-body-${filterName} input[type="checkbox"]`);
            const selectedValues = Array.from(checkboxes)
                .filter(cb => cb.checked)
                .map(cb => cb.value);
            
            const filter = window.currentFilters?.find(f => f.fieldName === filterName);
            if (filter) {
                filter.values = selectedValues;
                filter.isActive = selectedValues.length > 0 && selectedValues.length < filter.availableValues.length;
                updateFilterCount(filterName, selectedValues.length);
                
                // Обновляем только состояние фильтра, не применяем к таблице
                console.log('Обновили фильтр:', filterName, { selectedValues, isActive: filter.isActive });
                
                // Отмечаем, что фильтры изменены
                window.filtersChanged = true;
                updateBuildButtonText();
            }
        }
        
        function updateNumberFilter(filterName) {
            const minSlider = document.getElementById(`filter-${filterName}-min`);
            const maxSlider = document.getElementById(`filter-${filterName}-max`);
            const minLabel = document.getElementById(`filter-${filterName}-min-label`);
            const maxLabel = document.getElementById(`filter-${filterName}-max-label`);
            const rangeLabel = document.getElementById(`filter-${filterName}-range`);
            
            const minValue = parseInt(minSlider.value);
            const maxValue = parseInt(maxSlider.value);
            
            // Убеждаемся, что min <= max
            if (minValue > maxValue) {
                minSlider.value = maxValue;
                maxSlider.value = minValue;
            }
            
            minLabel.textContent = minValue;
            maxLabel.textContent = maxValue;
            rangeLabel.textContent = `${minValue} - ${maxValue}`;
            
            const filter = window.currentFilters?.find(f => f.fieldName === filterName);
            if (filter) {
                filter.minValue = minValue;
                filter.maxValue = maxValue;
                filter.isActive = minValue > filter.availableValues[0] || maxValue < filter.availableValues[filter.availableValues.length - 1];
                updateFilterCount(filterName, maxValue - minValue + 1);
                
                // Обновляем только состояние фильтра, не применяем к таблице
                console.log('Обновили фильтр:', filterName, { minValue, maxValue, isActive: filter.isActive });
                
                // Отмечаем, что фильтры изменены
                window.filtersChanged = true;
                updateBuildButtonText();
            }
        }
        
        function selectAllFilterValues(filterName) {
            const checkboxes = document.querySelectorAll(`#filter-body-${filterName} input[type="checkbox"]`);
            checkboxes.forEach(cb => cb.checked = true);
            updateTextFilter(filterName);
        }
        
        function clearFilterValues(filterName) {
            const checkboxes = document.querySelectorAll(`#filter-body-${filterName} input[type="checkbox"]`);
            checkboxes.forEach(cb => cb.checked = false);
            updateTextFilter(filterName);
        }
        
        function updateFilterCount(filterName, count) {
            const badge = document.getElementById(`filter-count-${filterName}`);
            if (badge) {
                badge.textContent = count;
                badge.className = count > 0 ? 'badge bg-primary ms-2' : 'badge bg-secondary ms-2';
            }
        }
        
        function resetAllFilters() {
            if (window.currentFilters) {
                window.currentFilters.forEach(filter => {
                    filter.reset();
                    if (filter.fieldType === 'text') {
                        clearFilterValues(filter.fieldName);
                    } else if (filter.fieldType === 'number') {
                        const minSlider = document.getElementById(`filter-${filter.fieldName}-min`);
                        const maxSlider = document.getElementById(`filter-${filter.fieldName}-max`);
                        if (minSlider && maxSlider) {
                            minSlider.value = filter.minValue;
                            maxSlider.value = filter.maxValue;
                            updateNumberFilter(filter.fieldName);
                        }
                    }
                });
                // Сбрасываем только состояние фильтров, не применяем к таблице
                console.log('Сбросили все фильтры');
            }
        }
        
        function updatePivotTableWithFilters() {
            console.log('=== updatePivotTableWithFilters ВЫЗВАНА ===');
            console.log('rawPivotData:', !!window.rawPivotData, window.rawPivotData?.length);
            console.log('currentPivotConfig:', !!window.currentPivotConfig);
            console.log('currentFilters:', window.currentFilters?.length);
            
            // Проверяем, что у нас есть данные и конфигурация
            if (window.rawPivotData && window.currentPivotConfig) {
                console.log('Обновляем сводную таблицу с учетом фильтров');
                
                // Получаем данные маппинга
                const mappingConfig = JSON.parse(sessionStorage.getItem('dataMapping') || '{}');
                
                // Определяем режим и поле для разбивки
                const splitValue = getSelectedSplitField();
                const mode = splitValue ? 'split-columns' : 
                    (pivotState.currentPivotMode === 'time-series' ? 'time-series' : 'slices');
                
                // Обновляем фильтры в конфигурации
                if (window.currentPivotConfig) {
                    window.currentPivotConfig.filters = window.currentFilters || [];
                }
                
                // Пересоздаем сводную таблицу с отфильтрованными данными
                if (typeof renderNewPivotTable === 'function') {
                    console.log('Вызываем renderNewPivotTable с обновленными фильтрами');
                    renderNewPivotTable(window.rawPivotData, mappingConfig, mode, splitValue, pivotState.currentPivotMode);
                        } else {
                    console.error('Функция renderNewPivotTable не найдена');
                }
                            } else {
                console.log('Нет необходимых данных для обновления сводной таблицы');
            }
        }
        
        // Получение выбранного среза
        function getSelectedSlice() {
            const radioButtons = document.querySelectorAll('input[name="splitFieldSelection"]');
            for (const radio of radioButtons) {
                if (radio.checked && radio.value !== '') {
                    return radio.value;
                }
            }
            return '';
        }

        // Функция для получения выбранного поля для разбивки
        function getSelectedSplitField() {
            const radioButtons = document.querySelectorAll('input[name="splitFieldSelection"]');
            for (const radio of radioButtons) {
                if (radio.checked && radio.value !== '') {
                    return radio.value;
                }
            }
            return '';
        }
        
        // Обновление текста кнопки "Построить график"
        function updateBuildButtonText() {
            const button = document.getElementById('buildChartBtn');
            if (button) {
                // Сохраняем onclick перед изменением innerHTML
                const onClickHandler = button.getAttribute('onclick');
                
                if (window.filtersChanged) {
                    button.innerHTML = '<i class="fas fa-chart-line me-2"></i>Применить фильтры и построить график';
                    button.className = 'btn btn-warning';
                } else {
                    button.innerHTML = '<i class="fas fa-chart-line me-2"></i>Построить график';
                    button.className = 'btn btn-primary';
                }
                
                // Восстанавливаем onclick после изменения innerHTML
                if (onClickHandler) {
                    button.setAttribute('onclick', onClickHandler);
                }
                        } else {
                console.error('❌ Кнопка buildChartBtn не найдена в updateBuildButtonText!');
            }
        }
        
        // Тестовая функция для проверки фильтров
        function testFilters() {
            console.log('Тестируем фильтры...');
            console.log('PivotFilter доступен:', typeof PivotFilter !== 'undefined');
            console.log('filtersContainer найден:', !!document.getElementById('filtersContainer'));
            console.log('rawPivotData доступен:', !!window.rawPivotData);
            console.log('currentPivotData доступен:', !!window.currentPivotData);
            
            if (window.rawPivotData) {
                console.log('Есть исходные данные для тестирования:', window.rawPivotData.length, 'строк');
                createAutoFilters();
                } else {
                console.log('Нет исходных данных для тестирования');
            }
        }
        
        // Тестовая функция для проверки кнопки
        function testButton() {
            console.log('🔍 Тестируем кнопку...');
            const button = document.getElementById('buildChartBtn');
            console.log('Кнопка найдена:', !!button);
            console.log('Кнопка элемент:', button);
            console.log('Кнопка onclick:', button?.onclick);
            console.log('Кнопка hasAttribute data-event-attached:', button?.hasAttribute('data-event-attached'));
            
            if (button) {
                // Пробуем привязать событие вручную
                button.addEventListener('click', function() {
                    console.log('🔴 КНОПКА НАЖАТА через тестовое событие!');
                    loadTimeSeriesData();
                });
                console.log('✅ Тестовое событие привязано к кнопке');
            }
        }
        
        // Функция диагностики состояния фильтров
        function diagnoseFilters() {
            console.log('=== ДИАГНОСТИКА ФИЛЬТРОВ ===');
            console.log('1. rawPivotData:', !!window.rawPivotData, window.rawPivotData?.length);
            console.log('2. currentPivotConfig:', !!window.currentPivotConfig);
            console.log('3. currentPivotRenderer:', !!window.currentPivotRenderer);
            console.log('4. currentFilters:', window.currentFilters?.length);
            console.log('5. currentFilters детали:', window.currentFilters);
            
            if (window.currentFilters) {
                window.currentFilters.forEach((filter, i) => {
                    console.log(`Фильтр ${i}:`, {
                        name: filter.fieldName,
                        type: filter.fieldType,
                        isActive: filter.isActive,
                        values: filter.values,
                        minValue: filter.minValue,
                        maxValue: filter.maxValue
                    });
                });
            }
            
            console.log('6. PivotData класс доступен:', typeof PivotData !== 'undefined');
            console.log('7. PivotFilter класс доступен:', typeof PivotFilter !== 'undefined');
            
            // Проверяем, есть ли данные в rawPivotData
            if (window.rawPivotData && window.rawPivotData.length > 0) {
                console.log('8. Пример данных из rawPivotData:', window.rawPivotData[0]);
            }
            
            // Дополнительная диагностика
            console.log('9. currentPivotData:', !!window.currentPivotData, window.currentPivotData?.length);
            console.log('10. sessionStorage dataMapping:', !!sessionStorage.getItem('dataMapping'));
            console.log('11. currentSessionId:', window.currentSessionId);
        }
        
        // Функция для принудительной установки rawPivotData из currentPivotData
        function forceSetRawData() {
            console.log('=== ПРИНУДИТЕЛЬНАЯ УСТАНОВКА rawPivotData ===');
            if (window.currentPivotData) {
                window.rawPivotData = window.currentPivotData;
                console.log('Установили rawPivotData из currentPivotData:', window.rawPivotData.length, 'строк');
                return true;
            } else {
                console.log('Нет currentPivotData для копирования');
                return false;
            }
        }
        
        // Автоматическое создание фильтров на основе данных
        function createAutoFilters() {
            console.log('🚀 === ФУНКЦИЯ createAutoFilters() ВЫЗВАНА ===');
            console.log('rawPivotData:', !!window.rawPivotData, window.rawPivotData?.length);
            console.log('PivotFilter доступен:', typeof PivotFilter !== 'undefined');
            
            // Проверяем доступность классов
            if (typeof PivotFilter === 'undefined') {
                console.error('❌ PivotFilter не определен! Проверьте загрузку static/pivot_table_system.js');
                return;
            }
            
            const filtersContainer = document.getElementById('filtersContainer');
            if (!filtersContainer) {
                console.error('Контейнер filtersContainer не найден!');
                return;
            }
            
            // Сохраняем текущее состояние фильтров перед очисткой
            const currentFilterStates = saveFilterStates();
            console.log('Сохранили состояние фильтров:', currentFilterStates);
            
            // Очищаем контейнер
            filtersContainer.innerHTML = '';
            
            // Сбрасываем флаг изменений фильтров
            window.filtersChanged = false;
            updateBuildButtonText();
            
            // Получаем данные маппинга
            const mappingConfig = JSON.parse(sessionStorage.getItem('dataMapping') || '{}');
            console.log('mappingConfig:', mappingConfig);
            
            if (!mappingConfig.columns) {
                console.log('Нет данных маппинга для создания фильтров');
                return;
            }
            
            if (!window.rawPivotData || window.rawPivotData.length === 0) {
                console.log('Нет rawPivotData для создания фильтров');
                return;
            }
            
            // Создаем объекты фильтров для системы
            window.currentFilters = [];
            
            // Создаем фильтры для временных рядов и срезов
            mappingConfig.columns.forEach(col => {
                if (col.include && (col.role === 'dimension' || col.time_series)) {
                    console.log('Создаем фильтр для колонки:', col.name, col.type, col.role);
                    
                    // Создаем HTML для фильтра
                    const filterHTML = createAutoFilterHTML(col);
                    filtersContainer.appendChild(filterHTML);
                    
                    // Определяем тип фильтра на основе фактического типа данных
                    const isNumeric = col.type === 'numeric';
                    const filterType = isNumeric ? 'number' : 'text';
                    
                    // Создаем объект фильтра для системы
                    const filter = new PivotFilter(col.name, filterType, col.name);
                    
                    // Устанавливаем значения для фильтра на основе типа
                    if (isNumeric) {
                        // Для числовых полей создаем слайдер
                        const values = window.rawPivotData?.map(row => parseFloat(row[col.name])).filter(v => !isNaN(v)) || [];
                        if (values.length > 0) {
                            filter.minValue = Math.min(...values);
                            filter.maxValue = Math.max(...values);
                            filter.availableValues = values.sort((a, b) => a - b);
                        }
                    } else {
                        // Для текстовых полей создаем чекбоксы
                        const uniqueValues = [...new Set(window.rawPivotData?.map(row => row[col.name]).filter(v => v !== null && v !== undefined) || [])];
                        filter.values = [];
                        filter.availableValues = uniqueValues.sort();
                    }
                    
                    window.currentFilters.push(filter);
                }
            });
            
            console.log('Автоматически создано фильтров:', window.currentFilters.length);
            
            // Восстанавливаем состояние фильтров
            restoreFilterStates(currentFilterStates);
        }
        
        // Сохранение состояния фильтров
        function saveFilterStates() {
            const states = {};
            if (window.currentFilters) {
                window.currentFilters.forEach(filter => {
                    states[filter.fieldName] = {
                        values: filter.values ? [...filter.values] : [],
                        minValue: filter.minValue,
                        maxValue: filter.maxValue,
                        isActive: filter.isActive
                    };
                });
            }
            return states;
        }
        
        // Восстановление состояния фильтров
        function restoreFilterStates(states) {
            if (!states || !window.currentFilters) return;
            
            window.currentFilters.forEach(filter => {
                const state = states[filter.fieldName];
                if (state) {
                    filter.values = state.values ? [...state.values] : [];
                    filter.minValue = state.minValue;
                    filter.maxValue = state.maxValue;
                    filter.isActive = state.isActive;
                    
                    // Восстанавливаем UI элементы
                    restoreFilterUI(filter.fieldName, state);
                }
            });
        }
        
        // Восстановление UI элементов фильтра
        function restoreFilterUI(filterName, state) {
            // Для числовых фильтров
            const minSlider = document.getElementById(`filter-${filterName}-min`);
            const maxSlider = document.getElementById(`filter-${filterName}-max`);
            if (minSlider && maxSlider && state.minValue !== undefined && state.maxValue !== undefined) {
                minSlider.value = state.minValue;
                maxSlider.value = state.maxValue;
                updateNumberFilter(filterName);
            }
            
            // Для текстовых фильтров
            const checkboxes = document.querySelectorAll(`#filter-body-${filterName} input[type="checkbox"]`);
            if (checkboxes.length > 0) {
                checkboxes.forEach(checkbox => {
                    checkbox.checked = state.values.includes(checkbox.value);
                });
                updateTextFilter(filterName);
            }
        }
        
        // Создание HTML для автоматического фильтра
        function createAutoFilterHTML(col) {
            const div = document.createElement('div');
            div.className = 'filter-card';
            div.id = `filter-${col.name}`;
            
            // Заголовок фильтра
            const header = document.createElement('div');
            header.className = 'filter-header';
            header.innerHTML = `
                <h6 class="mb-0">${col.name}</h6>
                <button class="btn btn-sm btn-outline-secondary" onclick="toggleFilter('${col.name}')">
                    <i class="fas fa-chevron-down me-1"></i>
                </button>
            `;
            div.appendChild(header);
            
            // Тело фильтра
            const body = document.createElement('div');
            body.className = 'filter-body';
            body.id = `filter-body-${col.name}`;
            body.style.display = 'none';
            
            // Определяем тип фильтра на основе фактического типа данных
            const isNumeric = col.type === 'numeric';
            
            if (isNumeric) {
                // Числовой фильтр со слайдерами
                const values = window.rawPivotData?.map(row => parseFloat(row[col.name])).filter(v => !isNaN(v)) || [];
                if (values.length > 0) {
                    const minVal = Math.min(...values);
                    const maxVal = Math.max(...values);
                    
                    body.innerHTML = `
                        <div class="filter-slider">
                            <div class="d-flex justify-content-between mb-2">
                                <span id="filter-${col.name}-min-label">${minVal}</span>
                                <span id="filter-${col.name}-range">${minVal} - ${maxVal}</span>
                                <span id="filter-${col.name}-max-label">${maxVal}</span>
                            </div>
                            <div class="row">
                                <div class="col-6">
                                    <label class="form-label small">От:</label>
                                    <input type="range" class="form-range" id="filter-${col.name}-min" 
                                           min="${minVal}" max="${maxVal}" value="${minVal}" 
                                           oninput="updateNumberFilter('${col.name}')">
                                </div>
                                <div class="col-6">
                                    <label class="form-label small">До:</label>
                                    <input type="range" class="form-range" id="filter-${col.name}-max" 
                                           min="${minVal}" max="${maxVal}" value="${maxVal}" 
                                           oninput="updateNumberFilter('${col.name}')">
                                </div>
                            </div>
                            <div class="mt-2">
                                <button class="btn btn-sm btn-outline-secondary" onclick="resetAllFilters()">
                                    Сбросить
                                </button>
                            </div>
                        </div>
                    `;
                }
            } else {
                // Текстовый фильтр с чекбоксами
                const uniqueValues = [...new Set(window.rawPivotData?.map(row => row[col.name]).filter(v => v !== null && v !== undefined) || [])].sort();
                
                if (uniqueValues.length > 0) {
                    const checkboxesHTML = uniqueValues.map(value => `
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="${value}" 
                                   id="filter-${col.name}-${value}" checked onchange="updateTextFilter('${col.name}')">
                            <label class="form-check-label" for="filter-${col.name}-${value}">
                                ${value}
                            </label>
                        </div>
                    `).join('');
                    
                    body.innerHTML = `
                        <div class="filter-checkboxes">
                            <div class="d-flex justify-content-between mb-2">
                                <button class="btn btn-sm btn-outline-primary" onclick="selectAllFilterValues('${col.name}')">
                                    Выбрать все
                                </button>
                                <button class="btn btn-sm btn-outline-secondary" onclick="clearFilterValues('${col.name}')">
                                    Очистить
                                </button>
                            </div>
                            <div class="filter-list" style="max-height: 150px; overflow-y: auto;">
                                ${checkboxesHTML}
                            </div>
                            <div class="mt-2">
                                <small class="text-muted" id="filter-${col.name}-count">
                                    Выбрано: ${uniqueValues.length}
                                </small>
                            </div>
                        </div>
                    `;
                }
            }
            
            div.appendChild(body);
            return div;
        }
        
        // Простая функция для создания фильтров временных рядов
        function createTimeSeriesFilters() {
            console.log('=== СОЗДАЕМ ФИЛЬТРЫ ВРЕМЕННЫХ РЯДОВ ===');
            
            const filtersContainer = document.getElementById('filtersContainer');
            if (!filtersContainer) {
                console.error('Контейнер filtersContainer не найден!');
                return;
            }
            
            // Очищаем контейнер
            filtersContainer.innerHTML = '';
            
            // Создаем простые фильтры для временных рядов
            const timeFilters = [
                { name: 'year', label: 'Год', type: 'number', min: 2020, max: 2024 },
                { name: 'month', label: 'Месяц', type: 'number', min: 1, max: 12 },
                { name: 'Quarter', label: 'Квартал', type: 'text', values: ['Q1', 'Q2', 'Q3', 'Q4'] },
                { name: 'Halfyear', label: 'Полугодие', type: 'text', values: ['H1', 'H2'] }
            ];
            
            // Создаем объекты фильтров для системы
            window.currentFilters = [];
            
            timeFilters.forEach(filterConfig => {
                // Создаем HTML для фильтра
                const filterHTML = createSimpleFilterHTML(filterConfig);
                filtersContainer.appendChild(filterHTML);
                
                // Создаем объект фильтра для системы
                const filter = new PivotFilter(filterConfig.name, filterConfig.type, filterConfig.label);
                
                // Устанавливаем значения для фильтра
                if (filterConfig.type === 'number') {
                    filter.minValue = filterConfig.min;
                    filter.maxValue = filterConfig.max;
                    filter.availableValues = Array.from({length: filterConfig.max - filterConfig.min + 1}, (_, i) => i + filterConfig.min);
                } else if (filterConfig.type === 'text') {
                    filter.values = [];
                    filter.availableValues = filterConfig.values;
                }
                
                window.currentFilters.push(filter);
                console.log('Создан фильтр:', filterConfig.name, filter);
            });
            
            console.log('Фильтры временных рядов созданы!', window.currentFilters);
        }
        
        function createSimpleFilterHTML(filter) {
            const div = document.createElement('div');
            div.className = 'filter-card';
            div.id = `filter-${filter.name}`;
            
            let bodyHTML = '';
            if (filter.type === 'text') {
                bodyHTML = createSimpleTextFilterHTML(filter);
            } else if (filter.type === 'number') {
                bodyHTML = createSimpleNumberFilterHTML(filter);
            }
            
            div.innerHTML = `
                <div class="filter-header filter-toggle" onclick="toggleFilter('${filter.name}')">
                    <i class="fas fa-chevron-down me-2"></i>${filter.label}
                    <span class="badge bg-secondary ms-2" id="filter-count-${filter.name}">${filter.type === 'text' ? filter.values.length : filter.max - filter.min + 1}</span>
                </div>
                <div class="filter-body" id="filter-body-${filter.name}" style="display: none;">
                    ${bodyHTML}
                </div>
            `;
            
            return div;
        }
        
        function createSimpleTextFilterHTML(filter) {
            const checkboxes = filter.values.map(value => `
                <div class="filter-checkbox-item">
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" value="${value}" 
                               id="filter-${filter.name}-${value}" 
                               onchange="updateTextFilter('${filter.name}')">
                        <label class="form-check-label" for="filter-${filter.name}-${value}">
                            ${value}
                        </label>
                    </div>
                </div>
            `).join('');
            
            return `
                <div class="filter-checkbox-list">
                    ${checkboxes}
                </div>
                <div class="mt-2">
                    <button class="btn btn-sm btn-outline-primary me-2" onclick="selectAllFilterValues('${filter.name}')">
                        Выбрать все
                    </button>
                    <button class="btn btn-sm btn-outline-secondary" onclick="clearFilterValues('${filter.name}')">
                        Очистить
                    </button>
                </div>
            `;
        }
        
        function createSimpleNumberFilterHTML(filter) {
            return `
                <div class="filter-slider-container">
                    <div class="filter-slider-label">От: <span id="filter-${filter.name}-min-label">${filter.min}</span></div>
                    <input type="range" class="form-range" 
                           id="filter-${filter.name}-min" 
                           min="${filter.min}" max="${filter.max}" 
                           value="${filter.min}"
                           oninput="updateNumberFilter('${filter.name}')">
                    
                    <div class="filter-slider-label">До: <span id="filter-${filter.name}-max-label">${filter.max}</span></div>
                    <input type="range" class="form-range" 
                           id="filter-${filter.name}-max" 
                           min="${filter.min}" max="${filter.max}" 
                           value="${filter.max}"
                           oninput="updateNumberFilter('${filter.name}')">
                    
                    <div class="filter-slider-value" id="filter-${filter.name}-range">
                        ${filter.min} - ${filter.max}
                    </div>
                </div>
            `;
        }

        function populateSelectsFromDataInfo(dataInfo, metricsSelect) {
            // Получаем настройки маппинга
            const mappingConfig = JSON.parse(sessionStorage.getItem('dataMapping') || '{}');
            
            // Заполняем селекты колонками из dataInfo
            dataInfo.columns.forEach((col, index) => {
                // Метрики - только колонки с ролью "metric"
                const columnMapping = mappingConfig.columns?.find(c => c.name === col);
                if (columnMapping && columnMapping.role === 'metric') {
                    const option2 = document.createElement('option');
                    option2.value = col;
                    option2.textContent = col;
                    metricsSelect.appendChild(option2);
                } else if (!mappingConfig.columns && dataInfo.dtypes && dataInfo.dtypes[col] && 
                    (dataInfo.dtypes[col].includes('int') || dataInfo.dtypes[col].includes('float'))) {
                    // Fallback: если нет маппинга, используем числовые колонки
                    const option2 = document.createElement('option');
                    option2.value = col;
                    option2.textContent = col;
                    metricsSelect.appendChild(option2);
                }
                
            });
        }

        // Функция для получения метрик из dataInfo
        function getMetricsFromDataInfo(dataInfo) {
            const mappingConfig = JSON.parse(sessionStorage.getItem('dataMapping') || '{}');
            const metrics = [];
            
            if (dataInfo.columns) {
                dataInfo.columns.forEach((col, index) => {
                    // Метрики - только колонки с ролью "metric"
                    const columnMapping = mappingConfig.columns?.find(c => c.name === col);
                    if (columnMapping && columnMapping.role === 'metric') {
                        metrics.push(col);
                } else if (!mappingConfig.columns && dataInfo.dtypes && dataInfo.dtypes[col] && 
                        (dataInfo.dtypes[col].includes('int') || dataInfo.dtypes[col].includes('float'))) {
                        // Fallback: если нет маппинга, используем числовые колонки
                        metrics.push(col);
                    }
                });
            }
            
            return metrics;
        }

        // Функция для создания чекбоксов метрик
        function createMetricsCheckboxes(availableMetrics) {
            const primaryFieldCheckboxes = document.getElementById('primaryFieldCheckboxes');
            primaryFieldCheckboxes.innerHTML = '';
            
            availableMetrics.forEach(metric => {
                const li = document.createElement('li');
                const checkboxId = 'metric_' + metric.replace(/[^a-zA-Z0-9]/g, '_');
                
                li.className = 'metrics-checkbox-item';
                li.innerHTML = '<div class="form-check"><input class="form-check-input" type="checkbox" id="' + checkboxId + '" value="' + metric + '" onchange="updateSelectedMetrics()"><label class="form-check-label" for="' + checkboxId + '">' + metric + '</label></div>';
                
                primaryFieldCheckboxes.appendChild(li);
            });
        }

        // Функция для создания чекбоксов срезов
        function createSlicesCheckboxes(availableSlices) {
            const primaryFieldCheckboxes = document.getElementById('primaryFieldCheckboxes');
            primaryFieldCheckboxes.innerHTML = '';
            
            availableSlices.forEach(slice => {
                const li = document.createElement('li');
                const checkboxId = 'slice_' + slice.name.replace(/[^a-zA-Z0-9]/g, '_');
                
                li.className = 'slices-checkbox-item';
                li.innerHTML = '<div class="form-check"><input class="form-check-input" type="checkbox" id="' + checkboxId + '" value="' + slice.name + '" onchange="updateSelectedSlices()"><label class="form-check-label" for="' + checkboxId + '">' + slice.name + '</label></div>';
                
                primaryFieldCheckboxes.appendChild(li);
            });
        }

        // Функция для выбора первой метрики по умолчанию
        function selectFirstMetric(firstMetric) {
            const checkboxId = 'metric_' + firstMetric.replace(/[^a-zA-Z0-9]/g, '_');
            const checkbox = document.getElementById(checkboxId);
            
            if (checkbox) {
                checkbox.checked = true;
                updateSelectedMetrics();
            }
        }

        // Функция для выбора первого среза по умолчанию
        function selectFirstSlice(firstSlice) {
            const checkboxId = 'slice_' + firstSlice.name.replace(/[^a-zA-Z0-9]/g, '_');
            const checkbox = document.getElementById(checkboxId);
            
            if (checkbox) {
                checkbox.checked = true;
                updateSelectedSlices();
            }
        }

        // Функция для обновления выбранных метрик
        function updateSelectedMetrics() {
            const checkboxes = document.querySelectorAll('#primaryFieldCheckboxes input[type="checkbox"]');
            const selectedMetrics = [];
            const primaryFieldDropdownText = document.getElementById('primaryFieldDropdownText');
            
            checkboxes.forEach(checkbox => {
                if (checkbox.checked) {
                    selectedMetrics.push(checkbox.value);
                }
            });
            
            // Обновляем текст дропбокса
            if (selectedMetrics.length === 0) {
                primaryFieldDropdownText.textContent = 'Выберите метрики';
            } else if (selectedMetrics.length === 1) {
                primaryFieldDropdownText.textContent = selectedMetrics[0];
            } else {
                primaryFieldDropdownText.textContent = 'Выбрано: ' + selectedMetrics.length;
            }
            
            // Сохраняем выбранные метрики в глобальной переменной
            window.selectedMetrics = selectedMetrics;
            pivotState.selectedMetrics = selectedMetrics;
            
            console.log('📊 Метрики обновлены:', selectedMetrics);
        }

        // Функция переключения режима сводной таблицы
        function switchPivotMode(mode) {
            console.log('🔄 switchPivotMode вызвана с режимом:', mode);
            console.log('🔄 Старый режим:', pivotState.currentPivotMode);
            pivotState.currentPivotMode = mode;
            console.log('🔄 Новый режим:', pivotState.currentPivotMode);
            
            // Обновляем активную кнопку
            document.getElementById('timeSeriesModeBtn').classList.toggle('active', mode === 'time-series');
            document.getElementById('slicesModeBtn').classList.toggle('active', mode === 'slices');
            
            // Обновляем заголовок
            const titleElement = document.getElementById('pivotModeTitle');
            const iconElement = titleElement.previousElementSibling;
            
            if (mode === 'time-series') {
                titleElement.textContent = 'Временные ряды';
                iconElement.className = 'fas fa-clock me-2';
                
                // Обновляем лейблы
                document.getElementById('primaryFieldLabel').textContent = 'Метрики';
                document.getElementById('splitFieldLabel').textContent = 'Разбивка по срезам';
                document.getElementById('noSplitFieldText').textContent = 'Только временные ряды';
                
                // Обновляем функции
                window.toggleAllPrimaryFields = toggleAllMetrics;
                window.updateSelectedSplitField = updateSelectedSlice;
            } else {
                titleElement.textContent = 'Срезы';
                iconElement.className = 'fas fa-layer-group me-2';
                
                // Обновляем лейблы
                document.getElementById('primaryFieldLabel').textContent = 'Метрики';
                document.getElementById('splitFieldLabel').textContent = 'Разбивка по временным рядам';
                document.getElementById('noSplitFieldText').textContent = 'Только срезы';
                
                // Обновляем функции
                window.toggleAllPrimaryFields = toggleAllMetrics;
                window.updateSelectedSplitField = updateSelectedTimeSeries;
            }
            
            // Перезагружаем выпадающие меню
            const mappingConfig = JSON.parse(sessionStorage.getItem('dataMapping') || '{}');
            console.log('switchPivotMode - проверяем доступность данных:', {
                mappingConfig: !!mappingConfig,
                mappingConfigKeys: Object.keys(mappingConfig),
                rawPivotData: !!window.rawPivotData,
                rawPivotDataLength: window.rawPivotData ? window.rawPivotData.length : 0
            });
            
            if (mappingConfig && Object.keys(mappingConfig).length > 0 && window.rawPivotData) {
                console.log('switchPivotMode - вызываем populateTimeSeriesSelects()');
                populateTimeSeriesSelects();
            } else {
                console.log('switchPivotMode - данные недоступны, не вызываем populateTimeSeriesSelects()');
            }
        }

        // Функция для переключения "Выбрать все"
        function toggleAllMetrics(selectAllCheckbox) {
            const checkboxes = document.querySelectorAll('#primaryFieldCheckboxes input[type="checkbox"]');
            
            checkboxes.forEach(checkbox => {
                checkbox.checked = selectAllCheckbox.checked;
            });
            
            updateSelectedMetrics();
        }

        // Функция для переключения "Выбрать все" для срезов
        function toggleAllSlices(selectAllCheckbox) {
            const checkboxes = document.querySelectorAll('#primaryFieldCheckboxes input[type="checkbox"]');
            
            checkboxes.forEach(checkbox => {
                checkbox.checked = selectAllCheckbox.checked;
            });
            
            updateSelectedSlices();
        }

        // Функция для обновления выбранных срезов
        function updateSelectedSlices() {
            const checkboxes = document.querySelectorAll('#primaryFieldCheckboxes input[type="checkbox"]:checked');
            const selectedSlices = Array.from(checkboxes).map(cb => cb.value);
            
            // Обновляем текст кнопки
            const buttonText = selectedSlices.length > 0 ? 
                `Выбрано срезов: ${selectedSlices.length}` : 
                'Выберите срезы';
            document.getElementById('primaryFieldDropdownText').textContent = buttonText;
            
            // Сохраняем выбранные срезы в глобальной переменной
            window.selectedSlices = selectedSlices;
        }

        // Функция для обновления выбранного временного ряда для разбивки
        function updateSelectedTimeSeries() {
            console.log('🔄 updateSelectedTimeSeries вызвана');
            const selectedRadio = document.querySelector('input[name="splitFieldSelection"]:checked');
            const selectedTimeSeries = selectedRadio ? selectedRadio.value : '';
            
            console.log('🔄 Выбранный временный ряд:', selectedTimeSeries);
            
            // Обновляем текст кнопки
            const buttonText = selectedTimeSeries ? 
                `Разбивка: ${selectedTimeSeries}` : 
                'Только срезы';
            document.getElementById('splitFieldDropdownText').textContent = buttonText;
            
            // Сохраняем выбранный временный ряд в глобальной переменной
            window.selectedTimeSeries = selectedTimeSeries;
            selectedSliceForSplit = selectedTimeSeries; // Исправление: обновляем selectedSliceForSplit
            console.log('🔄 window.selectedTimeSeries установлен:', window.selectedTimeSeries);
            console.log('🔄 selectedSliceForSplit установлен:', selectedSliceForSplit);
        }

        // Функция для получения срезов из dataInfo или mappingConfig
        function getSlicesFromDataInfo(dataInfo) {
            const mappingConfig = JSON.parse(sessionStorage.getItem('dataMapping') || '{}');
            const slices = [];
            
            if (mappingConfig.columns) {
                mappingConfig.columns.forEach(col => {
                    // Срезы - это колонки с ролью "dimension", которые не являются временными рядами
                    if (col.role === 'dimension' && (!col.time_series || col.time_series === '') && col.include) {
                        slices.push({
                            name: col.name,
                            level: col.nesting_level || 0
                    });
                }
            });
            
                // Сортируем срезы по уровню
                slices.sort((a, b) => a.level - b.level);
            }
            
            return slices;
        }

        // Функция для получения временных рядов из dataInfo или mappingConfig
        function getTimeSeriesFromDataInfo(dataInfo) {
            const mappingConfig = JSON.parse(sessionStorage.getItem('dataMapping') || '{}');
            const timeSeries = [];
            
            console.log('getTimeSeriesFromDataInfo вызвана с mappingConfig:', mappingConfig);
            
            if (mappingConfig.columns) {
                mappingConfig.columns.forEach(col => {
                    console.log('Проверяем колонку:', {
                        name: col.name,
                        role: col.role,
                        time_series: col.time_series,
                        include: col.include,
                        isTimeSeries: col.role === 'dimension' && col.time_series && col.time_series !== '' && col.include
                    });
                    
                    // Временные ряды - это колонки с ролью "dimension", которые имеют time_series
                    if (col.role === 'dimension' && col.time_series && col.time_series !== '' && col.include) {
                        timeSeries.push({
                            name: col.name,
                            level: col.nesting_level || 0
                        });
                        console.log('Добавлен временной ряд:', col.name);
                    }
                });
                
                // Сортируем временные ряды по уровню
                timeSeries.sort((a, b) => a.level - b.level);
            }
            
            console.log('getTimeSeriesFromDataInfo возвращает:', timeSeries);
            return timeSeries;
        }

        // Функция для создания радиокнопок срезов
        function createSlicesRadioButtons(availableSlices) {
            console.log('createSlicesRadioButtons вызвана с:', availableSlices);
            const splitFieldRadioButtons = document.getElementById('splitFieldRadioButtons');
            splitFieldRadioButtons.innerHTML = '';
                
                availableSlices.forEach(slice => {
                const li = document.createElement('li');
                const radioId = 'slice_' + slice.name.replace(/[^a-zA-Z0-9]/g, '_');
                
                li.className = 'slices-radio-item';
                li.innerHTML = '<div class="form-check"><input class="form-check-input" type="radio" name="splitFieldSelection" id="' + radioId + '" value="' + slice.name + '" onchange="updateSelectedSlice()"><label class="form-check-label" for="' + radioId + '">' + slice.name + ' (уровень ' + slice.level + ')</label></div>';
                
                splitFieldRadioButtons.appendChild(li);
            });
            
            console.log('Создано радиокнопок срезов:', availableSlices.length);
        }

        // Функция для создания радиокнопок временных рядов
        function createTimeSeriesRadioButtons(availableTimeSeries) {
            console.log('createTimeSeriesRadioButtons вызвана с:', availableTimeSeries);
            const splitFieldRadioButtons = document.getElementById('splitFieldRadioButtons');
            splitFieldRadioButtons.innerHTML = '';
                
            availableTimeSeries.forEach(timeSeries => {
                const li = document.createElement('li');
                const radioId = 'timeseries_' + timeSeries.name.replace(/[^a-zA-Z0-9]/g, '_');
                
                li.className = 'timeseries-radio-item';
                li.innerHTML = '<div class="form-check"><input class="form-check-input" type="radio" name="splitFieldSelection" id="' + radioId + '" value="' + timeSeries.name + '" onchange="updateSelectedTimeSeries()"><label class="form-check-label" for="' + radioId + '">' + timeSeries.name + ' (уровень ' + timeSeries.level + ')</label></div>';
                
                splitFieldRadioButtons.appendChild(li);
            });
            
            console.log('Создано радиокнопок временных рядов:', availableTimeSeries.length);
        }

        // Функция для обновления выбранного среза
        function updateSelectedSlice() {
            const radioButtons = document.querySelectorAll('input[name="splitFieldSelection"]');
            const splitFieldDropdownText = document.getElementById('splitFieldDropdownText');
            let selectedSlice = '';
            
            radioButtons.forEach(radio => {
                if (radio.checked) {
                    selectedSlice = radio.value;
                }
            });
            
            // Обновляем текст дропбокса
            if (!selectedSlice) {
                splitFieldDropdownText.textContent = 'Только временные ряды';
            } else {
                splitFieldDropdownText.textContent = selectedSlice;
            }
            
            // Сохраняем выбранный срез в глобальной переменной
            window.selectedSlice = selectedSlice;
            selectedSliceForSplit = selectedSlice;
            
            // Обновляем сводную таблицу при изменении среза
            updatePivotTableWithSplit();
        }

        function loadTimeSeriesData() {
            console.log('🔧 ВЕРСИЯ КОДА: 2.2.2 - Исправлена логика разбивки в режиме срезов, восстановлена функциональность коллапсирования');
            console.log('🔥 === ФУНКЦИЯ loadTimeSeriesData() ВЫЗВАНА ===');
            console.log('currentSessionId:', currentSessionId);
            console.log('window.selectedMetrics:', window.selectedMetrics);
            console.log('window.currentFilters:', window.currentFilters);
            console.log('window.filtersChanged:', window.filtersChanged);
            
            // Проверяем, что сессия инициализирована
            if (!currentSessionId) {
                console.error('Сессия не инициализирована');
                alert('Ошибка: сессия не найдена. Пожалуйста, загрузите данные заново.');
                return;
            }
            
            // Проверяем наличие выбранных полей в зависимости от режима
            if (pivotState.currentPivotMode === 'time-series') {
                if (!window.selectedMetrics || window.selectedMetrics.length === 0) {
                    alert('Выберите хотя бы одну метрику');
                    return;
                }
                    } else {
                if (!window.selectedSlices || window.selectedSlices.length === 0) {
                    alert('Выберите хотя бы один срез');
                    return;
                }
            }
            
            // Автоматически определяем временную ось из настроек маппинга
            const mappingConfig = JSON.parse(sessionStorage.getItem('dataMapping') || '{}');
            let timeColumn = '';
            
            if (mappingConfig.columns) {
                // Находим колонку с наименьшим уровнем вложенности среди временных рядов
                const timeSeriesCols = mappingConfig.columns
                    .filter(col => col.time_series && col.time_series !== '')
                    .sort((a, b) => (a.nesting_level || 0) - (b.nesting_level || 0));
                
                if (timeSeriesCols.length > 0) {
                    timeColumn = timeSeriesCols[0].name;
                }
            }
            
            console.log('loadTimeSeriesData вызвана:', {
                timeColumn: timeColumn,
                metricsSelect: metricsSelect,
                currentSessionId: currentSessionId
            });
            
            if (!timeColumn) {
                alert('Не найдена временная ось в настройках маппинга');
                return;
            }
            
            const selectedMetrics = window.selectedMetrics;
            
            // Показываем загрузку
            const chartContainer = document.getElementById('timeSeriesChartContainer');
            chartContainer.innerHTML = '<div class="text-center"><div class="spinner-border text-primary" role="status"></div><p class="mt-2">Загрузка данных...</p></div>';
            
            // Формируем URL для запроса
            const params = new URLSearchParams();
            params.append('time_column', timeColumn);
            
            // Добавляем поля в зависимости от режима
            if (pivotState.currentPivotMode === 'time-series') {
                window.selectedMetrics.forEach(metric => params.append('metrics', metric));
            } else {
                window.selectedSlices.forEach(slice => params.append('slices', slice));
            }
            
            // Всегда показываем сводную таблицу
            params.append('show_pivot', 'true');
            // Передаем режим сводной таблицы
            params.append('pivot_mode', pivotState.currentPivotMode);
            
            // Передаем параметр разбивки
            let splitValue = '';
            if (pivotState.currentPivotMode === 'time-series') {
                splitValue = window.selectedSlice || '';
            } else {
                splitValue = window.selectedTimeSeries || '';
            }
            if (!splitValue) {
                const radioButtons = document.querySelectorAll('input[name="splitFieldSelection"]');
                radioButtons.forEach(radio => {
                    if (radio.checked) {
                        splitValue = radio.value;
                    }
                });
            }
            if (splitValue) {
                params.append('split_by_slice', splitValue);
                console.log('Добавлен параметр split_by_slice:', splitValue);
            } else {
                console.log('split_by_slice пустое значение');
            }
            
            // Передаем данные маппинга
            const mappingData = JSON.parse(sessionStorage.getItem('dataMapping') || '{}');
            if (mappingData && mappingData.columns && mappingData.columns.length > 0) {
                params.append('mapping_data', JSON.stringify(mappingData));
                console.log('Передаем данные маппинга в запросе:', mappingData.columns.length, 'колонок');
            } else {
                console.warn('Данные маппинга не найдены в sessionStorage');
            }
            
            // Передаем настройки маппинга (используем уже объявленную переменную)
            // params.append('mapping_data', JSON.stringify(mappingConfig)); // Удалено - дублирование
            
            console.log('Параметры запроса:', {
                sessionId: currentSessionId,
                timeColumn: timeColumn,
                metrics: selectedMetrics,
                url: `/api/get_time_series_data/${currentSessionId}?${params}`
            });
            
            // Загружаем данные
            fetch(`/api/get_time_series_data/${currentSessionId}?${params}`)
                .then(response => response.json())
                .then(data => {
                    console.log('Получены данные временных рядов:', data);
                    console.log('Структура данных:', {
                        success: data.success,
                        hasData: !!data.data,
                        dataKeys: data.data ? Object.keys(data.data) : [],
                        hasPivotTable: !!(data.data && data.data.pivot_table)
                    });
                    
                    if (data.success) {
                        if (data.data.pivot_table) {
                            console.log('Обрабатываем сводную таблицу:', data.data.pivot_table);
                            console.log('Структура pivot_table от сервера:', {
                                columns: data.data.pivot_table.columns,
                                dataLength: data.data.pivot_table.data ? data.data.pivot_table.data.length : 0,
                                firstRow: data.data.pivot_table.data ? data.data.pivot_table.data[0] : null,
                                hasColumnHeaders: !!data.data.pivot_table.column_headers,
                                splitBySlice: data.data.pivot_table.split_by_slice,
                                uniqueSlices: data.data.pivot_table.unique_slices,
                                metrics: data.data.pivot_table.metrics,
                                time_series_info: data.data.pivot_table.time_series_info,
                                available_slices: data.data.pivot_table.available_slices
                            });
                            
                            // Сохраняем данные для новой системы
                            currentPivotData = data.data.pivot_table.data;
                            // Сохраняем исходные данные для фильтров
                            window.rawPivotData = data.data.pivot_table.raw_data || data.data.pivot_table.data;
                            console.log('Сохранили данные для новой системы:', currentPivotData.length, 'строк');
                            console.log('Сохранили исходные данные для фильтров:', window.rawPivotData.length, 'строк');
                            console.log('Проверяем наличие raw_data в ответе:', !!data.data.pivot_table.raw_data);
                            console.log('Структура pivot_table:', Object.keys(data.data.pivot_table));
                            console.log('Первая строка сохраненных данных:', currentPivotData[0]);
                            
                            // Показываем и сводную таблицу, и график
                            // Получаем выбранный срез из нового дропбокса
                            let selectedSlice = selectedSliceForSplit || '';
                            if (!selectedSlice) {
                                const radioButtons = document.querySelectorAll('input[name="sliceSelection"]');
                                radioButtons.forEach(radio => {
                                    if (radio.checked) {
                                        selectedSlice = radio.value;
                                    }
                                });
                            }
                            console.log('Вызываем новую систему сводной таблицы с selectedSlice:', selectedSlice);
                            
                            // Получаем данные маппинга
                            const mappingData = JSON.parse(sessionStorage.getItem('dataMapping') || '{}');
                            // Добавляем выбранные метрики в данные маппинга
                            if (window.selectedMetrics) {
                                mappingData.selectedMetrics = window.selectedMetrics;
                            }
                            
                            // Используем новую систему сводных таблиц
                            if (typeof renderNewPivotTable === 'function') {
                                // Получаем значение для разбивки
                                let splitValue = '';
                                if (pivotState.currentPivotMode === 'time-series') {
                                    splitValue = selectedSlice || '';
                                } else {
                                    splitValue = window.selectedTimeSeries || '';
                                }
                                
                                const mode = pivotState.currentPivotMode === 'time-series' ? 
                                    (splitValue ? 'split-columns' : 'time-series') : 
                                    (splitValue ? 'split-columns' : 'slices');
                                console.log('🎯 === НАЧИНАЕМ ПРИМЕНЕНИЕ ФИЛЬТРОВ ===');
                                console.log('renderNewPivotTable доступна:', typeof renderNewPivotTable);
                                console.log('mode:', mode);
                                console.log('splitValue:', splitValue);
                                
                                // Сначала создаем фильтры если их нет
                                if (!window.currentFilters || window.currentFilters.length === 0) {
                                    console.log('Создаем фильтры перед рендерингом...');
                                    createAutoFilters();
                                }
                                
                                // Применяем фильтры к данным перед рендерингом
                                console.log('🔍 Проверяем фильтры:', {
                                    hasFilters: !!window.currentFilters,
                                    filtersCount: window.currentFilters?.length || 0,
                                    currentFilters: window.currentFilters
                                });
                                
                                if (window.currentFilters && window.currentFilters.length > 0) {
                                    console.log('✅ Есть фильтры, применяем их к данным перед рендерингом:', window.currentFilters.map(f => ({
                                        name: f.fieldName,
                                        isActive: f.isActive,
                                        type: f.fieldType
                                    })));
                                    
                                    // Фильтруем данные
                                    const activeFilters = window.currentFilters.filter(f => f.isActive);
                                    console.log('🔍 Активные фильтры:', activeFilters.length, activeFilters.map(f => f.fieldName));
                                    
                                    if (activeFilters.length > 0) {
                                        console.log('📊 Исходные данные:', currentPivotData.length, 'строк');
                                        const filteredData = currentPivotData.filter(row => {
                                            return activeFilters.every(filter => filter.matches(row));
                                        });
                                        console.log(`🎯 Фильтрация данных: ${currentPivotData.length} -> ${filteredData.length} строк`);
                                        
                                        // Используем отфильтрованные данные
                                        renderNewPivotTable(filteredData, mappingData, mode, splitValue, pivotState.currentPivotMode);
                                    } else {
                                        console.log('⚠️ Нет активных фильтров, используем все данные');
                                        renderNewPivotTable(currentPivotData, mappingData, mode, splitValue, pivotState.currentPivotMode);
                                    }
                                } else {
                                    console.log('⚠️ Нет фильтров, используем все данные');
                                    renderNewPivotTable(currentPivotData, mappingData, mode, splitValue);
                                }
                                
                                // Сбрасываем флаг изменений фильтров после применения
                                window.filtersChanged = false;
                                updateBuildButtonText();
                                
                                // Автоматически создаем фильтры после успешного рендеринга (только если их не было)
                                console.log('Автоматически создаем фильтры с данными:', {
                                    rawPivotData: window.rawPivotData?.length,
                                    mappingData: mappingData?.columns?.length
                                });
                                console.log('rawPivotData детали:', window.rawPivotData);
                                console.log('mappingData детали:', mappingData);
                                
                                // Проверяем наличие данных перед созданием фильтров
                                console.log('=== ПРОВЕРЯЕМ ДАННЫЕ ДЛЯ ФИЛЬТРОВ ===');
                                console.log('window.rawPivotData:', !!window.rawPivotData, window.rawPivotData?.length);
                                console.log('mappingData:', !!mappingData, mappingData?.columns?.length);
                                console.log('window.currentPivotData:', !!window.currentPivotData, window.currentPivotData?.length);
                                
                                if (window.rawPivotData && mappingData) {
                                    console.log('✅ Данные есть, создаем фильтры...');
                                    try {
                                        createAutoFilters();
                                        console.log('✅ createAutoFilters() вызвана успешно');
                                    } catch (error) {
                                        console.error('❌ Ошибка в createAutoFilters():', error);
                                    }
                                } else {
                                    console.log('⚠️ Нет данных для создания фильтров, пытаемся использовать currentPivotData...');
                                    if (window.currentPivotData) {
                                        window.rawPivotData = window.currentPivotData;
                                        console.log('✅ Скопировали currentPivotData в rawPivotData');
                                        try {
                                            createAutoFilters();
                                            console.log('✅ createAutoFilters() вызвана успешно (fallback)');
                                        } catch (error) {
                                            console.error('❌ Ошибка в createAutoFilters() (fallback):', error);
                                        }
                                    } else {
                                        console.log('❌ Нет данных вообще для создания фильтров');
                                    }
                                }
                        } else {
                                console.error('Функция renderNewPivotTable не найдена');
                            }
                        } else {
                            console.log('Нет сводной таблицы в ответе сервера');
                            console.log('Данные от сервера:', data.data);
                            
                            // Проверяем наличие данных для графика
                            if (data.data && (data.data.time_series || data.data.grouped_series)) {
                                renderTimeSeriesChart(data.data);
                            } else {
                                console.log('Нет данных для отображения');
                                const container = document.getElementById('timeSeriesChartContainer');
                                if (container) {
                                    container.innerHTML = '<div class="alert alert-info">Нет данных для отображения</div>';
                                }
                            }
                            
                            // Попробуем создать сводную таблицу из обычных данных
                            if (data.data && data.data.data) {
                                console.log('Создаем сводную таблицу из обычных данных');
                                console.log('Первые 3 строки данных:', data.data.data.slice(0, 3));
                                console.log('Структура данных:', Object.keys(data.data.data[0] || {}));
                                
                                // Получаем выбранную метрику из дропбокса
                                const metricsSelect = document.getElementById('metricsSelect');
                                const selectedMetric = metricsSelect && metricsSelect.value ? metricsSelect.value : 'revenue_first_transactions';
                                console.log('Выбранная метрика для сводной таблицы:', selectedMetric);
                                
                                // Проверяем, есть ли выбранная метрика в данных
                                const hasSelectedMetric = data.data.data.some(row => row[selectedMetric] !== undefined);
                                console.log('Есть ли выбранная метрика в данных:', hasSelectedMetric);
                                
                                if (!hasSelectedMetric) {
                                    console.log('Выбранная метрика не найдена, используем первую доступную');
                                    const availableMetrics = Object.keys(data.data.data[0] || {}).filter(key => 
                                        key !== 'year' && key !== 'month' && key !== 'quarter'
                                    );
                                    const fallbackMetric = availableMetrics[0] || 'revenue_first_transactions';
                                    console.log('Используем метрику:', fallbackMetric);
                                }
                                
                                const pivotData = {
                                    data: data.data.data,
                                    columns: Object.keys(data.data.data[0] || {}),
                                    metrics: [selectedMetric] // используем выбранную метрику
                                };
                                
                                currentPivotData = pivotData.data;
                                console.log('Создали сводную таблицу из данных:', currentPivotData.length, 'строк');
                                
                                // Показываем сводную таблицу
                                let selectedSlice = selectedSliceForSplit || '';
                                if (!selectedSlice) {
                                    const radioButtons = document.querySelectorAll('input[name="sliceSelection"]');
                                    radioButtons.forEach(radio => {
                                        if (radio.checked) {
                                            selectedSlice = radio.value;
                            }
                        });
                    }
                                renderPivotTableAndChart(pivotData, data.data, selectedSlice);
                } else {
                                console.log('Нет данных для отображения');
                            renderTimeSeriesChart(data.data);
                            }
                        }
                    } else {
                        console.error('Ошибка от сервера:', data.message);
                        alert('Ошибка: ' + data.message);
                        chartContainer.innerHTML = '<div class="alert alert-danger">Ошибка загрузки данных</div>';
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('Ошибка при загрузке данных');
                    chartContainer.innerHTML = '<div class="alert alert-danger">Ошибка загрузки данных</div>';
                });
        }

        function renderTimeSeriesChart(data) {
            console.log('renderTimeSeriesChart вызвана с данными:', data);
            
            let canvas = document.getElementById('timeSeriesChart');
            let chartContainer = document.getElementById('timeSeriesChartContainer');
            
            if (!canvas) {
                // Если canvas не найден, создаем его
                if (!chartContainer) {
                    console.error('Контейнер timeSeriesChartContainer не найден');
                return;
                }
                
                // Создаем canvas элемент
                canvas = document.createElement('canvas');
                canvas.id = 'timeSeriesChart';
                canvas.width = 400;
                canvas.height = 200;
                chartContainer.innerHTML = '';
                chartContainer.appendChild(canvas);
                console.log('Создан новый canvas элемент timeSeriesChart');
            }
            
            // Уничтожаем предыдущий график, если он существует
            if (currentChart) {
                currentChart.destroy();
                currentChart = null;
            }
            
            console.log('Canvas найден, предыдущий график уничтожен');
            
            // Подготавливаем данные для Chart.js
            const datasets = [];
            const colors = ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40'];
            
            if (data.grouped_series && Object.keys(data.grouped_series).length > 0) {
                // Группированные данные
                let colorIndex = 0;
                for (const [groupName, groupData] of Object.entries(data.grouped_series)) {
                    for (const [metric, values] of Object.entries(groupData)) {
                        datasets.push({
                            label: `${metric} (${groupName})`,
                            data: values,
                            borderColor: colors[colorIndex % colors.length],
                            backgroundColor: colors[colorIndex % colors.length] + '20',
                            fill: false,
                            tension: 0.1
                        });
                        colorIndex++;
                    }
                            }
                        } else {
                // Обычные данные
                data.time_series.forEach((series, index) => {
                datasets.push({
                        label: series.metric,
                        data: series.data,
                    borderColor: colors[index % colors.length],
                    backgroundColor: colors[index % colors.length] + '20',
                    fill: false,
                    tension: 0.1
                });
            });
            }
            
            // Создаем график
            console.log('Создаем график с данными:', {
                labels: data.time_labels,
                datasets: datasets
            });
            
            try {
                const ctx = canvas.getContext('2d');
                currentChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                            labels: data.time_labels,
                        datasets: datasets
                    },
                    options: {
                            responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Значение'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                        text: 'Время'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            title: {
                                display: true,
                                    text: 'Временные ряды'
                            }
                    }
                }
            });
                    console.log('График создан успешно:', currentChart);
            } catch (error) {
                    console.error('Ошибка при создании графика:', error);
                    // Показываем ошибку в контейнере
                    const container = document.getElementById('timeSeriesContainer');
                    if (container) {
                        container.innerHTML = '<div class="alert alert-danger">Ошибка при создании графика: ' + error.message + '</div>';
                    }
                }
        }

        function renderPivotTable(pivotData) {
            console.log('renderPivotTable вызвана с данными:', pivotData);
            
            const chartContainer = document.getElementById('timeSeriesChartContainer');
            if (!chartContainer) {
                console.error('Элемент timeSeriesChartContainer не найден');
                return;
            }
            
            // Создаем HTML для сводной таблицы
            let html = '<div class="pivot-table-container">';
            html += '<h6><i class="fas fa-table me-2"></i>Сводная таблица с учетом вложенности</h6>';
            
            if (pivotData.time_series_info && pivotData.time_series_info.length > 0) {
                html += '<div class="mb-3">';
                html += '<small class="text-muted">Временные ряды: ';
                pivotData.time_series_info.forEach((ts, index) => {
                    html += `${ts.name} (${ts.type}, уровень ${ts.level})`;
                    if (index < pivotData.time_series_info.length - 1) html += ' → ';
                });
                html += '</small></div>';
            }
            
            html += '<div class="table-responsive" style="max-height: 400px; overflow-y: auto;">';
            html += '<table class="table table-sm table-striped table-bordered">';
            
            // Заголовки
            html += '<thead class="table-dark">';
            html += '<tr>';
            pivotData.columns.forEach(col => {
                html += `<th>${col}</th>`;
            });
            html += '</tr>';
            html += '</thead>';
            
            // Данные
            html += '<tbody>';
            pivotData.data.forEach(row => {
                html += '<tr>';
                pivotData.columns.forEach(col => {
                    const value = row[col];
                    html += `<td>${value !== null && value !== undefined ? value : ''}</td>`;
                });
                html += '</tr>';
            });
            html += '</tbody>';
            
            html += '</table>';
            html += '</div>';
            html += '</div>';
            
            chartContainer.innerHTML = html;
        }

        // Функция для отображения простой таблицы обработанных данных
        function showProcessedDataTable(data, mappingColumns) {
            console.log('Отображаем простую таблицу обработанных данных');
            console.log('Данные:', data.length, 'строк');
            console.log('Колонки маппинга:', mappingColumns.length);
            
            const container = document.getElementById('timeSeriesChartContainer');
            if (!container) {
                console.error('Контейнер timeSeriesChartContainer не найден');
                return;
            }
            
            if (!data || data.length === 0) {
                container.innerHTML = '<div class="alert alert-warning">Нет данных для отображения</div>';
                return;
            }
            
            // Создаем заголовки таблицы
            const timeColumns = mappingColumns.filter(col => col.role === 'time' || col.time_series);
            const metricColumns = mappingColumns.filter(col => col.role === 'metric');
            const sliceColumns = mappingColumns.filter(col => col.role === 'slice');
            
            console.log('Временные колонки:', timeColumns.map(col => col.name));
            console.log('Метрики:', metricColumns.map(col => col.name));
            console.log('Срезы:', sliceColumns.map(col => col.name));
            
            let html = '<div class="table-responsive">';
            html += '<h5>Обработанные данные после маппинга</h5>';
            html += '<p class="text-muted">Показываем первые 100 строк из ' + data.length + ' строк</p>';
            html += '<table class="table table-sm table-striped table-bordered">';
            
            // Заголовки
            html += '<thead class="table-dark"><tr>';
            mappingColumns.forEach(col => {
                const badgeClass = col.role === 'time' ? 'bg-primary' : 
                                  col.role === 'metric' ? 'bg-success' : 
                                  col.role === 'slice' ? 'bg-warning' : 'bg-secondary';
                html += `<th><span class="badge ${badgeClass}">${col.role}</span> ${col.name}</th>`;
            });
            html += '</tr></thead>';
            
            // Данные (показываем первые 100 строк)
            html += '<tbody>';
            const rowsToShow = Math.min(100, data.length);
            for (let i = 0; i < rowsToShow; i++) {
                const row = data[i];
                html += '<tr>';
                mappingColumns.forEach(col => {
                    const value = row[col.name];
                    let displayValue = '';
                    
                    if (value === null || value === undefined) {
                        displayValue = '<span class="text-muted">-</span>';
                    } else if (col.role === 'metric' && typeof value === 'number') {
                        // Форматируем числа
                        displayValue = value.toLocaleString('ru-RU');
                        if (value === 0) {
                            displayValue = `<span class="text-muted">${displayValue}</span>`;
                        }
            } else {
                        displayValue = String(value);
                    }
                    
                    html += `<td>${displayValue}</td>`;
                    });
                    html += '</tr>';
            }
            html += '</tbody>';
            
            html += '</table>';
            
            // Статистика
            html += '<div class="mt-3">';
            html += '<h6>Статистика данных:</h6>';
            html += '<ul>';
            html += `<li>Всего строк: ${data.length.toLocaleString('ru-RU')}</li>`;
            html += `<li>Временных колонок: ${timeColumns.length}</li>`;
            html += `<li>Метрик: ${metricColumns.length}</li>`;
            html += `<li>Срезов: ${sliceColumns.length}</li>`;
            
            // Проверяем наличие ненулевых значений в метриках
            if (metricColumns.length > 0) {
                const firstRow = data[0];
                const nonZeroMetrics = metricColumns.filter(col => {
                    const value = parseFloat(firstRow[col.name]);
                    return !isNaN(value) && value !== 0;
                });
                html += `<li>Метрик с ненулевыми значениями: ${nonZeroMetrics.length} из ${metricColumns.length}</li>`;
                
                if (nonZeroMetrics.length === 0) {
                    html += '<li class="text-danger"><strong>ВНИМАНИЕ: Все метрики содержат нулевые значения!</strong></li>';
                }
            }
            
            html += '</ul>';
            html += '</div>';
            
            html += '</div>';
            
            container.innerHTML = html;
            console.log('Таблица обработанных данных отображена');
        }

        function renderPivotTableAndChart(pivotData, chartData, selectedSlice = '') {
            console.log('renderPivotTableAndChart вызвана с данными (новая система):', {pivotData, chartData, selectedSlice});
            
            // Проверяем, что новая система загружена
            console.log('Проверка доступности функций:');
            console.log('- renderNewPivotTable:', typeof renderNewPivotTable);
            console.log('- PivotFilter:', typeof PivotFilter);
            console.log('- PivotData:', typeof PivotData);
            console.log('- window.renderNewPivotTable:', typeof window.renderNewPivotTable);
            
            if (typeof renderNewPivotTable === 'undefined') {
                console.error('Функция renderNewPivotTable не определена! Проверьте загрузку static/pivot_table_system.js');
                console.error('Возможные причины:');
                console.error('1. Синтаксическая ошибка в JavaScript файле');
                console.error('2. Файл не загрузился полностью');
                console.error('3. Ошибка в экспорте функций');
                
                const container = document.getElementById('timeSeriesChartContainer');
                if (container) {
                    container.innerHTML = '<div class="alert alert-danger">Ошибка: новая система сводной таблицы не загружена. Проверьте консоль браузера.</div>';
                }
                return;
            }
            
                            // Проверяем, что данные маппинга загружены
                            const mappingData = JSON.parse(sessionStorage.getItem('dataMapping') || '{}');
                            console.log('Проверяем загруженные данные маппинга:', mappingData);
                            
                            if (!mappingData || !mappingData.columns || mappingData.columns.length === 0) {
                                console.error('Данные маппинга не загружены! Сначала загрузите данные.');
                                const container = document.getElementById('timeSeriesChartContainer');
                                if (container) {
                                    container.innerHTML = '<div class="alert alert-warning">Данные маппинга не загружены. Сначала загрузите данные для анализа.</div>';
                                }
                return;
            }
            
                            // Используем данные от сервера (уже преобразованные после маппинга)
                            console.log('Используем данные от сервера после маппинга');
                            console.log('Количество колонок в маппинге:', mappingData.columns.length);
                            console.log('Колонки маппинга:', mappingData.columns.map(col => `${col.name} (${col.role})`));
                            
                            // Получаем выбранную метрику
            const metricsSelect = document.getElementById('metricsSelect');
                            const selectedMetric = metricsSelect && metricsSelect.value ? metricsSelect.value : 'revenue_first_transactions';
                            console.log('Выбранная метрика:', selectedMetric);
                            
                            // Определяем режим отображения
                            const mode = selectedSlice ? 'split-columns' : 'time-series';
                            console.log('Режим сводной таблицы:', mode);
                            
                            // Проверяем все возможные источники данных
                            console.log('=== ДИАГНОСТИКА ИСТОЧНИКОВ ДАННЫХ ===');
                            
                            // 1. Проверяем currentPivotData
                            console.log('1. currentPivotData:', currentPivotData ? currentPivotData.length + ' строк' : 'не определен');
                            if (currentPivotData && currentPivotData.length > 0) {
                                console.log('   Первая строка currentPivotData:', currentPivotData[0]);
                            }
                            
                            // 2. Проверяем chartData
                            console.log('2. chartData:', chartData ? 'определен' : 'не определен');
                            if (chartData) {
                                console.log('   chartData.data:', chartData.data ? chartData.data.length + ' строк' : 'не определен');
                                console.log('   chartData.pivot_table:', chartData.pivot_table ? 'определен' : 'не определен');
                                if (chartData.data && chartData.data.length > 0) {
                                    console.log('   Первая строка chartData.data:', chartData.data[0]);
                                }
                                if (chartData.pivot_table && chartData.pivot_table.data) {
                                    console.log('   chartData.pivot_table.data:', chartData.pivot_table.data.length + ' строк');
                                    console.log('   Первая строка pivot_table.data:', chartData.pivot_table.data[0]);
                                }
                            }
                            
                            // 3. Проверяем данные маппинга
                            console.log('3. Данные маппинга:');
                            if (mappingData.data && mappingData.data.length > 0) {
                                console.log('   mappingData.data:', mappingData.data.length + ' строк');
                                console.log('   Первая строка mappingData.data:', mappingData.data[0]);
            } else {
                                console.log('   mappingData.data: не определен');
                            }
                            
                            // Выбираем лучший источник данных
                            let dataToUse;
                            let dataSource = '';
                            
                            if (mappingData.data && mappingData.data.length > 0) {
                                dataToUse = mappingData.data;
                                dataSource = 'mappingData.data';
                                console.log('Используем данные из mappingData.data');
                            } else if (chartData.data && chartData.data.length > 0) {
                                dataToUse = chartData.data;
                                dataSource = 'chartData.data';
                                console.log('Используем данные из chartData.data');
                            } else if (currentPivotData && currentPivotData.length > 0) {
                                dataToUse = currentPivotData;
                                dataSource = 'currentPivotData';
                                console.log('Используем данные из currentPivotData');
                    } else {
                                console.error('Нет данных для отображения');
                                const container = document.getElementById('timeSeriesChartContainer');
                                if (container) {
                                    container.innerHTML = '<div class="alert alert-warning">Нет данных для отображения сводной таблицы.</div>';
                                }
                    return;
                }
                
                            console.log('Выбранный источник данных:', dataSource, 'с', dataToUse.length, 'строками');
                            console.log('Первые 3 строки выбранных данных:', dataToUse.slice(0, 3));
                            console.log('Структура выбранных данных:', Object.keys(dataToUse[0] || {}));
                            
                            // Проверяем, есть ли реальные значения в выбранных данных
                            const firstRow = dataToUse[0];
                            const hasNonZeroValues = Object.keys(firstRow).some(key => {
                                if (key !== 'year' && key !== 'month' && key !== 'quarter' && key !== 'Halfyear') {
                                    const value = parseFloat(firstRow[key]);
                                    return !isNaN(value) && value !== 0;
                                }
                                return false;
                            });
                            console.log('Есть ли ненулевые значения в выбранных данных:', hasNonZeroValues);
                            
                            if (!hasNonZeroValues) {
                                console.warn('ВНИМАНИЕ: Все значения метрик равны нулю в выбранных данных!');
                                console.log('Детальный анализ первой строки:');
                                Object.keys(firstRow).forEach(key => {
                                    const value = firstRow[key];
                                    console.log(`  ${key}: ${value} (тип: ${typeof value})`);
                                });
                            }
                            
                            // Создаем маппинг для новой системы сводной таблицы
                            const mappingForPivot = {
                                columns: mappingData.columns,
                                selectedMetric: selectedMetric
                            };
                            
                            console.log('Маппинг для сводной таблицы:', mappingForPivot);
                            
                            // Показываем простую таблицу обработанных данных
                            showProcessedDataTable(dataToUse, mappingData.columns);
                            return;
            
            // Fallback на старую систему, если нет данных
            console.log('Fallback на старую систему - нет данных для новой системы');
            const container = document.getElementById('timeSeriesChartContainer');
            if (container) {
                container.innerHTML = '<div class="text-center"><div class="spinner-border text-primary" role="status"></div><p class="mt-2">Загрузка данных...</p></div>';
            }
        }

        // Удалена дублированная упрощенная версия renderTimeSeriesChart
        // Используется полная версия функции выше


        function editMapping() {
            window.location.href = '/forecast/mapping';
        }

        function showDataTable() {
            console.log('showDataTable вызвана (упрощенная версия)');
            // Упрощенная версия - просто логируем
        }

        function loadTimeSeriesData() {
            console.log('🔧 ВЕРСИЯ КОДА: 2.2.2 - Исправлена логика разбивки в режиме срезов, восстановлена функциональность коллапсирования');
            // Проверяем, что сессия инициализирована
            if (!currentSessionId) {
                console.error('Сессия не инициализирована');
                alert('Ошибка: сессия не найдена. Пожалуйста, загрузите данные заново.');
                return;
            }
            
            console.log('loadTimeSeriesData вызвана для сессии:', currentSessionId);
            
            // Определяем временную колонку из маппинга
            let timeColumn = '';
            const mappingConfig = JSON.parse(sessionStorage.getItem('dataMapping') || '{}');
            if (mappingConfig && mappingConfig.columns) {
                // Находим колонку с наименьшим уровнем вложенности среди временных рядов
                const timeSeriesCols = mappingConfig.columns
                    .filter(col => col.time_series && col.time_series !== '')
                    .sort((a, b) => (a.nesting_level || 0) - (b.nesting_level || 0));
                
                if (timeSeriesCols.length > 0) {
                    timeColumn = timeSeriesCols[0].name;
                }
            }
            
            console.log('loadTimeSeriesData вызвана:', {
                currentSessionId,
                timeColumn,
                selectedSliceForSplit
            });
            
            // Формируем параметры запроса
            const params = new URLSearchParams();
            if (timeColumn) {
            params.append('time_column', timeColumn);
            }
            
            // Добавляем метрики из выбранных в дропбоксе
            if (window.selectedMetrics && window.selectedMetrics.length > 0) {
                window.selectedMetrics.forEach(metric => {
                    params.append('metrics', metric);
                });
                console.log('Добавляем выбранные метрики:', window.selectedMetrics);
                    } else {
                // Fallback: если ничего не выбрано, используем первую метрику из маппинга
                if (mappingConfig && mappingConfig.columns) {
                    const metrics = mappingConfig.columns
                        .filter(col => col.role === 'metric')
                        .map(col => col.name);
                    
                    if (metrics.length > 0) {
                        params.append('metrics', metrics[0]);
                        console.log('Добавляем первую метрику из маппинга:', metrics[0]);
                    }
                }
            }
            
            // Добавляем параметр разбивки по срезам, если выбран
            if (selectedSliceForSplit) {
                params.append('split_by_slice', selectedSliceForSplit);
                console.log('Добавляем параметр split_by_slice:', selectedSliceForSplit);
            }
            
            // Добавляем параметры для показа сводной таблицы
            params.append('show_pivot', 'true');
            params.append('pivot_mode', pivotState.currentPivotMode);
            
            // Передаем данные маппинга
            const mappingData = JSON.parse(sessionStorage.getItem('dataMapping') || '{}');
            if (mappingData && mappingData.columns && mappingData.columns.length > 0) {
                params.append('mapping_data', JSON.stringify(mappingData));
                console.log('Передаем данные маппинга в запросе:', mappingData.columns.length, 'колонок');
                } else {
                console.warn('Данные маппинга не найдены в sessionStorage');
            }
            
            console.log('Параметры запроса:', params.toString());
            
            // Загружаем данные
            const chartContainer = document.getElementById('timeSeriesChartContainer');
            if (chartContainer) {
                chartContainer.innerHTML = '<div class="text-center"><div class="spinner-border text-primary" role="status"></div><p class="mt-2">Загрузка данных...</p></div>';
            }
            
            fetch(`/api/get_time_series_data/${currentSessionId}?${params}`)
                .then(response => response.json())
                .then(data => {
                    console.log('🎯 === ПОЛУЧЕН ОТВЕТ ОТ API (второй fetch) ===');
                    console.log('Получены данные временных рядов:', data);
                    if (data.success) {
                        if (data.data.pivot_table) {
                            console.log('Обрабатываем сводную таблицу:', data.data.pivot_table);
                            console.log('Структура pivot_table:', {
                            columns: data.data.pivot_table.columns,
                                hasColumnHeaders: !!data.data.pivot_table.column_headers,
                                splitBySlice: data.data.pivot_table.split_by_slice,
                                uniqueSlices: data.data.pivot_table.unique_slices,
                                metrics: data.data.pivot_table.metrics
                            });
                            
                            // Сохраняем данные для новой системы
                            currentPivotData = data.data.pivot_table.data;
                            console.log('Сохранили данные для новой системы:', currentPivotData.length, 'строк');
                            
                            // Показываем и сводную таблицу, и график
                            // Получаем выбранный срез из нового дропбокса
                            let selectedSlice = selectedSliceForSplit || '';
                            if (!selectedSlice) {
                                const radioButtons = document.querySelectorAll('input[name="sliceSelection"]');
                                radioButtons.forEach(radio => {
                                    if (radio.checked) {
                                        selectedSlice = radio.value;
                    }
                });
            }
                            console.log('Вызываем новую систему сводной таблицы с selectedSlice:', selectedSlice);
                            
                            // Получаем данные маппинга
                            const mappingData = JSON.parse(sessionStorage.getItem('dataMapping') || '{}');
                            // Добавляем выбранные метрики в данные маппинга
                            if (window.selectedMetrics) {
                                mappingData.selectedMetrics = window.selectedMetrics;
                            }
                            
                            // Используем новую систему сводных таблиц
                            if (typeof renderNewPivotTable === 'function') {
                                // Получаем значение для разбивки
                                let splitValue = '';
                                if (pivotState.currentPivotMode === 'time-series') {
                                    splitValue = selectedSlice || '';
                                } else {
                                    splitValue = window.selectedTimeSeries || '';
                                }
                                
                                const mode = pivotState.currentPivotMode === 'time-series' ? 
                                    (splitValue ? 'split-columns' : 'time-series') : 
                                    (splitValue ? 'split-columns' : 'slices');
                                console.log('🎯 === НАЧИНАЕМ ПРИМЕНЕНИЕ ФИЛЬТРОВ (второй fetch) ===');
                                console.log('renderNewPivotTable доступна:', typeof renderNewPivotTable);
                                console.log('mode:', mode);
                                console.log('splitValue:', splitValue);
                                console.log('currentPivotData длина:', currentPivotData.length);
                                console.log('window.currentFilters:', window.currentFilters);
                                
                                // Применяем фильтры к данным перед рендерингом
                                if (window.currentFilters && window.currentFilters.length > 0) {
                                    console.log('✅ Есть фильтры, применяем их к данным:', window.currentFilters.map(f => ({
                                        name: f.fieldName,
                                        isActive: f.isActive,
                                        type: f.fieldType
                                    })));
                                    
                                    const activeFilters = window.currentFilters.filter(f => f.isActive);
                                    if (activeFilters.length > 0) {
                                        console.log('🔍 Активные фильтры:', activeFilters.length, activeFilters.map(f => f.fieldName));
                                        
                                        // Отладка структуры данных и фильтра
                                        console.log('🔍 Первая строка данных:', currentPivotData[0]);
                                        console.log('🔍 Ключи первой строки:', Object.keys(currentPivotData[0]));
                                        console.log('🔍 Значение year в первой строке:', currentPivotData[0].year);
                                        console.log('🔍 Тип значения year:', typeof currentPivotData[0].year);
                                        console.log('🔍 Есть ли year в строке:', 'year' in currentPivotData[0]);
                                        console.log('🔍 hasOwnProperty year:', currentPivotData[0].hasOwnProperty('year'));
                                        
                                        // Проверим несколько строк с разными значениями year
                                        const yearsInData = [...new Set(currentPivotData.slice(0, 100).map(row => row.year))].sort();
                                        console.log('🔍 Уникальные значения year в первых 100 строках:', yearsInData);
                                        console.log('🔍 Фильтр year:', activeFilters[0]);
                                        console.log('🔍 minValue фильтра:', activeFilters[0].minValue);
                                        console.log('🔍 maxValue фильтра:', activeFilters[0].maxValue);
                                        console.log('🔍 Тест фильтра на первой строке:', activeFilters[0].matches(currentPivotData[0]));
                                        
                                        // Проверяем несколько строк
                                        for (let i = 0; i < Math.min(5, currentPivotData.length); i++) {
                                            const row = currentPivotData[i];
                                            const matches = activeFilters[0].matches(row);
                                            console.log(`🔍 Строка ${i}: year=${row.year}, matches=${matches}`);
                                        }
                                        
                                        const filteredData = currentPivotData.filter(row => {
                                            return activeFilters.every(filter => filter.matches(row));
                                        });
                                        console.log(`🎯 Фильтрация данных: ${currentPivotData.length} -> ${filteredData.length} строк`);
                                        renderNewPivotTable(filteredData, mappingData, mode, splitValue, pivotState.currentPivotMode);
                } else {
                                        console.log('⚠️ Нет активных фильтров, используем все данные');
                                        renderNewPivotTable(currentPivotData, mappingData, mode, splitValue, pivotState.currentPivotMode);
                                    }
                                } else {
                                    console.log('⚠️ Нет фильтров, используем все данные');
                                    renderNewPivotTable(currentPivotData, mappingData, mode, splitValue);
                                }
                                
                                // Сбрасываем флаг изменений фильтров после применения
                                window.filtersChanged = false;
                                updateBuildButtonText();
            } else {
                                console.error('Функция renderNewPivotTable не найдена');
                            }
                    } else {
                            console.log('Нет сводной таблицы, показываем только график');
                            if (data.data && (data.data.time_series || data.data.grouped_series)) {
                                renderTimeSeriesChart(data.data);
                            } else {
                                console.log('Нет данных для отображения графика');
                                const container = document.getElementById('timeSeriesChartContainer');
                                if (container) {
                                    container.innerHTML = '<div class="alert alert-info">Нет данных для отображения графика</div>';
                                }
                            }
                        }
                } else {
                        console.error('Ошибка загрузки данных:', data);
                        if (chartContainer) {
                            const errorMessage = data.message || data.error || 'Неизвестная ошибка';
                            chartContainer.innerHTML = `<div class="alert alert-danger">Ошибка загрузки данных: ${errorMessage}</div>`;
                        }
                }
            })
            .catch(error => {
                console.error('Error:', error);
                    alert('Ошибка при загрузке данных');
                    if (chartContainer) {
                        chartContainer.innerHTML = '<div class="alert alert-danger">Ошибка загрузки данных</div>';
                    }
                });
        }

        // Функция для заполнения опций группировки
        function populateGroupingOptions(pivotData) {
            console.log('populateGroupingOptions вызвана (упрощенная версия)');
            // Упрощенная версия - просто логируем
        }

        // Функция для обновления таблицы без параметров
        function updatePivotTable() {
            console.log('updatePivotTable вызвана (упрощенная версия)');
            // Упрощенная версия - просто логируем
        }
        

        // Функция для показа колонок сводной таблицы
        function showPivotColumns(maxLevel) {
            console.log('showPivotColumns вызвана (упрощенная версия)');
            // Упрощенная версия - просто логируем
        }
        
        // Функция для скрытия колонок сводной таблицы
        function hidePivotColumns(hiddenLevel) {
            console.log('hidePivotColumns вызвана (упрощенная версия)');
            // Упрощенная версия - просто логируем
        }
        
        // Функция для обновления состояний плюсов/минусов
        function updateToggleStates(currentLevel) {
            console.log('updateToggleStates вызвана (упрощенная версия)');
            // Упрощенная версия - просто логируем
        }
        
        // Функция для обновления графика на основе состояния сводной таблицы
        function updateChartFromPivotState(selectedSlice = '') {
            console.log('updateChartFromPivotState вызвана (упрощенная версия)');
            // Упрощенная версия - просто логируем
        }

        // Функция для агрегации данных сводной таблицы
        function aggregatePivotData(pivotData, hiddenLevel) {
            console.log('aggregatePivotData вызвана (упрощенная версия)');
            return [];
        }

        function showForecastResults(data) {
            const forecastInterface = document.getElementById('forecastInterface');
            forecastInterface.innerHTML = `
                <div class="card">
                    <div class="card-header">
                        <h5><i class="fas fa-chart-line me-2"></i>Результаты прогнозирования</h5>
                    </div>
                    <div class="card-body">
                        <div class="alert alert-success">
                            <h6><i class="fas fa-check me-2"></i>Прогноз выполнен успешно!</h6>
                            <p>Метод: ${data.method}</p>
                            <p>Период: ${data.periods} месяцев</p>
                            <p>Целевая метрика: ${data.target_metric}</p>
                        </div>
                        <div class="text-center">
                            <button class="btn btn-primary me-2" onclick="downloadResults('csv')">
                                <i class="fas fa-download me-2"></i>Скачать CSV
                            </button>
                            <button class="btn btn-success me-2" onclick="downloadResults('excel')">
                                <i class="fas fa-download me-2"></i>Скачать Excel
                            </button>
                            <button class="btn btn-info" onclick="downloadResults('report')">
                                <i class="fas fa-file-pdf me-2"></i>Отчет
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }

        function downloadResults(format) {
            if (!currentSessionId) {
                alert('Нет активной сессии');
                return;
            }
            
            window.open('/download/' + format + '/' + currentSessionId, '_blank');
        }

        function goToForecastSettings() {
            // Проверяем, что данные загружены
            if (!currentSessionId) {
                alert('Сначала загрузите данные');
                return;
            }
            
            // Сохраняем текущий session_id
            sessionStorage.setItem('currentSessionId', currentSessionId);
            
            // Переходим на страницу настройки прогноза
            window.location.href = `/forecast/settings?session_id=${currentSessionId}`;
        }
    </script>
</body>
</html>
