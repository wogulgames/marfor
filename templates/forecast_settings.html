<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MARFOR - Настройка прогноза</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        .btn-primary {
            background-color: #81db99 !important;
            border-color: #81db99 !important;
            color: #000 !important;
        }
        
        .btn-primary:hover {
            background-color: #6bc884 !important;
        }
        
        .timeline-container {
            display: flex;
            overflow-x: auto;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            gap: 10px;
        }
        
        .timeline-year {
            display: flex;
            flex-direction: column;
            min-width: 400px;
        }
        
        .year-header {
            font-size: 0.95em;
            font-weight: bold;
            padding: 6px 10px;
            background: #2196f3;
            color: white;
            text-align: center;
            border-radius: 6px 6px 0 0;
            margin-bottom: 5px;
        }
        
        .year-header.forecast {
            background: #ff9800;
        }
        
        .timeline-months {
            display: flex;
            gap: 4px;
            padding: 5px;
            background: white;
            border-radius: 0 0 6px 6px;
        }
        
        .month-cell {
            width: 28px;
            height: 50px;
            border: 1.5px solid #2196f3;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: white;
            cursor: default;
            transition: all 0.2s;
            position: relative;
        }
        
        .month-cell.forecast {
            border-color: #ff9800;
            background: #fff3e0;
        }
        
        .month-cell.empty {
            opacity: 0.2;
            border-style: dashed;
        }
        
        .month-number {
            font-size: 0.85em;
            font-weight: bold;
        }
        
        .month-label {
            font-size: 0.55em;
            color: #666;
            margin-top: 2px;
        }
        
        .forecast-controls {
            background: #fff3e0;
            border: 2px solid #ff9800;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <!-- Навигация -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container-fluid">
            <a class="navbar-brand d-flex align-items-center" href="/forecast">
                <img src="/static/images/logo.png" alt="MARFOR Logo" height="32" class="me-2" style="object-fit: contain;">
                <strong>MARFOR</strong>
            </a>
            <span class="navbar-text">
                <i class="fas fa-cog me-2"></i>Настройка прогноза
            </span>
            <div class="ms-auto">
                <span class="badge bg-success" style="font-size: 0.8em;">
                    <i class="fas fa-code"></i> v2.18.0
                </span>
            </div>
        </div>
    </nav>

    <!-- Основной контент -->
    <div class="container-fluid mt-4">
        <div class="row">
            <div class="col-12">
                <!-- Выбор метрики -->
                <div class="card mb-3">
                    <div class="card-header bg-primary text-dark">
                        <h6 class="mb-0">
                            <i class="fas fa-chart-bar me-2"></i>Выбор метрики для прогнозирования
                        </h6>
                    </div>
                    <div class="card-body">
                        <div class="row align-items-center">
                            <div class="col-md-4">
                                <label class="form-label">Метрика:</label>
                                <select id="metricSelect" class="form-select" onchange="updateMetricChart()">
                                    <option value="">Загрузка...</option>
                                </select>
                            </div>
                            <div class="col-md-8">
                                <div class="alert alert-info mb-0">
                                    <i class="fas fa-info-circle me-2"></i>
                                    Выберите метрику, для которой будет построен прогноз. График автоматически обновится.
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- График метрики -->
                <div class="card mb-3">
                    <div class="card-header bg-primary text-dark">
                        <h6 class="mb-0">
                            <i class="fas fa-chart-line me-2"></i>График выбранной метрики
                        </h6>
                    </div>
                    <div class="card-body">
                        <canvas id="metricChart" style="height: 400px; width: 100%;"></canvas>
                    </div>
                </div>

                <!-- Настройка горизонта прогноза -->
                <div class="card mb-3">
                    <div class="card-header bg-warning text-dark">
                        <h6 class="mb-0">
                            <i class="fas fa-calendar-plus me-2"></i>Настройка горизонта прогноза
                        </h6>
                    </div>
                    <div class="card-body">
                        <div class="forecast-controls">
                            <div class="row align-items-center">
                                <div class="col-md-4">
                                    <label class="form-label fw-bold">Горизонт прогноза (месяцы):</label>
                                    <input type="number" id="forecastMonths" class="form-control" min="1" max="36" value="12" placeholder="Введите количество месяцев">
                                </div>
                                <div class="col-md-4">
                                    <label class="form-label">&nbsp;</label>
                                    <button class="btn btn-warning w-100" onclick="setForecastHorizon()">
                                        <i class="fas fa-calendar-check me-2"></i>Задать горизонт прогноза
                                    </button>
                                </div>
                                <div class="col-md-4">
                                    <div class="alert alert-warning mb-0" style="font-size: 0.9em;">
                                        <i class="fas fa-info-circle me-2"></i>
                                        Укажите на сколько месяцев вперед нужен прогноз
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Сводка -->
                        <div id="forecastSummary" style="display: none;" class="alert alert-success mt-3">
                            <h6><i class="fas fa-check-circle me-2"></i>Настроен горизонт прогноза:</h6>
                            <div id="forecastSummaryContent"></div>
                        </div>
                    </div>
                </div>

                <!-- Временная шкала -->
                <div class="card mb-3">
                    <div class="card-header bg-primary text-dark">
                        <h6 class="mb-0">
                            <i class="fas fa-calendar-alt me-2"></i>Временная шкала
                            <small class="text-muted ms-2">(прокрутите вправо для просмотра всех периодов)</small>
                        </h6>
                    </div>
                    <div class="card-body">
                        <div class="timeline-container" id="timelineContainer">
                            <p class="text-muted">Загрузка...</p>
                        </div>
                    </div>
                </div>

                <!-- Кнопки действий -->
                <div class="text-center mb-4">
                    <button class="btn btn-secondary btn-lg me-3" onclick="goBack()">
                        <i class="fas fa-arrow-left me-2"></i>Назад
                    </button>
                    <button class="btn btn-success btn-lg" onclick="saveForecastSettings()">
                        <i class="fas fa-save me-2"></i>Сохранить и запустить прогноз
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        let currentSessionId = null;
        let timeSeriesConfig = null;
        let existingTimeSeries = [];
        let forecastMonthsCount = 0;
        let forecastPeriods = [];
        let chartInstance = null;
        let metrics = [];
        let selectedMetric = null;
        let metricData = {};
        let timelineData = []; // Все периоды (фактические + прогнозные)

        // Инициализация при загрузке страницы
        document.addEventListener('DOMContentLoaded', async function() {
            const urlParams = new URLSearchParams(window.location.search);
            currentSessionId = urlParams.get('session_id') || sessionStorage.getItem('currentSessionId');
            
            if (!currentSessionId) {
                alert('Сессия не найдена. Вернитесь на главную страницу.');
                window.location.href = '/forecast';
                return;
            }
            
            await loadData();
        });

        async function loadData() {
            try {
                const mappingStr = sessionStorage.getItem('dataMapping');
                const mapping = mappingStr ? JSON.parse(mappingStr) : null;
                
                if (!mapping || !mapping.columns) {
                    alert('Настройки маппинга не найдены. Вернитесь на страницу маппинга.');
                    window.location.href = '/forecast/mapping';
                    return;
                }
                
                // Находим метрики и временные поля
                metrics = [];
                timeSeriesConfig = {};
                
                mapping.columns.forEach(col => {
                    if (col.role === 'metric' && col.include) {
                        metrics.push({
                            name: col.name,
                            displayName: col.name
                        });
                    }
                    if (col.time_series && col.include) {
                        timeSeriesConfig[col.time_series] = col.name;
                    }
                });
                
                console.log('Метрики:', metrics);
                console.log('Временные поля:', timeSeriesConfig);
                
                populateMetricSelect();
                await loadTimeSeries();
                buildTimelineData();
                renderTimeline();
                await loadMetricData();
                
            } catch (error) {
                console.error('Ошибка загрузки данных:', error);
                alert('Ошибка загрузки данных: ' + error.message);
            }
        }

        function populateMetricSelect() {
            const select = document.getElementById('metricSelect');
            select.innerHTML = '';
            
            if (metrics.length === 0) {
                select.innerHTML = '<option value="">Метрики не найдены</option>';
                return;
            }
            
            metrics.forEach((metric, index) => {
                const option = document.createElement('option');
                option.value = metric.name;
                option.text = metric.displayName;
                if (index === 0) {
                    option.selected = true;
                    selectedMetric = metric.name;
                }
                select.appendChild(option);
            });
        }

        async function loadTimeSeries() {
            try {
                const mappingStr = sessionStorage.getItem('dataMapping');
                const mapping = mappingStr ? JSON.parse(mappingStr) : null;
                
                if (!mapping) {
                    console.error('Маппинг не найден в sessionStorage');
                    return;
                }
                
                const mappingParam = encodeURIComponent(JSON.stringify(mapping));
                const response = await fetch(`/api/get_time_series_values/${currentSessionId}?mapping=${mappingParam}`);
                const result = await response.json();
                
                if (result.success) {
                    existingTimeSeries = result.time_series;
                    console.log('Загружено временных рядов:', existingTimeSeries.length);
                } else {
                    console.error('Ошибка:', result.message);
                }
            } catch (error) {
                console.error('Ошибка загрузки временных рядов:', error);
            }
        }

        async function loadMetricData() {
            if (!selectedMetric) return;
            
            try {
                const response = await fetch(`/api/get_metric_time_series/${currentSessionId}?metric=${selectedMetric}`);
                const result = await response.json();
                
                if (result.success) {
                    metricData = result.data;
                    console.log('Данные метрики загружены:', metricData);
                    renderMetricChart();
                } else {
                    console.error('Ошибка загрузки данных метрики:', result.message);
                }
            } catch (error) {
                console.error('Ошибка:', error);
            }
        }

        function buildTimelineData() {
            timelineData = [];
            
            // Группируем по годам и месяцам
            const yearMonths = {};
            
            existingTimeSeries.forEach(item => {
                if (!item.year || !item.month) return;
                
                const year = item.year;
                const month = item.month;
                
                if (!yearMonths[year]) {
                    yearMonths[year] = new Set();
                }
                yearMonths[year].add(month);
            });
            
            // Преобразуем в массив для отображения
            Object.keys(yearMonths).sort((a, b) => a - b).forEach(year => {
                const months = Array.from(yearMonths[year]).sort((a, b) => a - b);
                
                months.forEach(month => {
                    timelineData.push({
                        year: parseInt(year),
                        month: parseInt(month),
                        isForecast: false,
                        quarter: Math.ceil(month / 3),
                        halfyear: month <= 6 ? 1 : 2
                    });
                });
            });
            
            console.log('Построена временная шкала:', timelineData.length, 'периодов');
        }

        function setForecastHorizon() {
            const monthsInput = document.getElementById('forecastMonths');
            const months = parseInt(monthsInput.value);
            
            if (isNaN(months) || months < 1 || months > 36) {
                alert('Укажите количество месяцев от 1 до 36');
                return;
            }
            
            forecastMonthsCount = months;
            
            // Определяем последний период из фактических данных
            if (timelineData.length === 0) {
                alert('Нет фактических данных для определения горизонта');
                return;
            }
            
            const lastPeriod = timelineData[timelineData.length - 1];
            let currentYear = lastPeriod.year;
            let currentMonth = lastPeriod.month;
            
            // Очищаем старые прогнозные периоды
            timelineData = timelineData.filter(p => !p.isForecast);
            forecastPeriods = [];
            
            // Добавляем прогнозные месяцы
            for (let i = 0; i < months; i++) {
                currentMonth++;
                if (currentMonth > 12) {
                    currentMonth = 1;
                    currentYear++;
                }
                
                timelineData.push({
                    year: currentYear,
                    month: currentMonth,
                    isForecast: true,
                    quarter: Math.ceil(currentMonth / 3),
                    halfyear: currentMonth <= 6 ? 1 : 2
                });
            }
            
            console.log('Добавлено прогнозных периодов:', months);
            console.log('Всего периодов на шкале:', timelineData.length);
            
            // Группируем прогнозные периоды по годам для сохранения
            const forecastByYear = {};
            timelineData.filter(p => p.isForecast).forEach(p => {
                if (!forecastByYear[p.year]) {
                    forecastByYear[p.year] = {
                        year: p.year,
                        months: [],
                        quarters: new Set(),
                        halfyears: new Set()
                    };
                }
                forecastByYear[p.year].months.push(p.month);
                forecastByYear[p.year].quarters.add(`Q${p.quarter}`);
                forecastByYear[p.year].halfyears.add(`H${p.halfyear}`);
            });
            
            forecastPeriods = Object.values(forecastByYear).map(y => ({
                year: y.year,
                months: y.months,
                quarters: Array.from(y.quarters),
                halfyears: Array.from(y.halfyears)
            }));
            
            renderTimeline();
            renderMetricChart();
            updateForecastSummary();
        }

        function renderTimeline() {
            const container = document.getElementById('timelineContainer');
            
            if (timelineData.length === 0) {
                container.innerHTML = '<p class="text-muted">Нет данных</p>';
                return;
            }
            
            // Группируем по годам
            const yearGroups = {};
            timelineData.forEach(period => {
                if (!yearGroups[period.year]) {
                    yearGroups[period.year] = [];
                }
                yearGroups[period.year].push(period);
            });
            
            let html = '';
            
            Object.keys(yearGroups).sort((a, b) => a - b).forEach(year => {
                const periods = yearGroups[year];
                const isForecastYear = periods.some(p => p.isForecast);
                
                html += `<div class="timeline-year">`;
                html += `<div class="year-header ${isForecastYear ? 'forecast' : ''}">${year}</div>`;
                html += `<div class="timeline-months">`;
                
                // Отображаем все 12 месяцев
                for (let m = 1; m <= 12; m++) {
                    const period = periods.find(p => p.month === m);
                    
                    if (period) {
                        const cellClass = period.isForecast ? 'month-cell forecast' : 'month-cell';
                        const monthNames = ['Янв', 'Фев', 'Мар', 'Апр', 'Май', 'Июн', 'Июл', 'Авг', 'Сен', 'Окт', 'Ноя', 'Дек'];
                        
                        html += `<div class="${cellClass}" data-year="${year}" data-month="${m}">`;
                        html += `<div class="month-number">${m}</div>`;
                        html += `<div class="month-label">${monthNames[m-1]}</div>`;
                        html += `</div>`;
                    } else {
                        // Пустая ячейка для месяцев без данных
                        html += `<div class="month-cell" style="opacity: 0.3; border-style: dashed;">`;
                        html += `<div class="month-number">${m}</div>`;
                        html += `</div>`;
                    }
                }
                
                html += `</div>`;
                html += `</div>`;
            });
            
            container.innerHTML = html;
            
            // Автоматически прокручиваем к последнему году
            setTimeout(() => {
                const lastYear = container.querySelector('.timeline-year:last-child');
                if (lastYear) {
                    lastYear.scrollIntoView({ behavior: 'smooth', inline: 'center' });
                }
            }, 100);
        }

        function updateForecastSummary() {
            const summaryDiv = document.getElementById('forecastSummary');
            const contentDiv = document.getElementById('forecastSummaryContent');
            
            if (forecastMonthsCount === 0) {
                summaryDiv.style.display = 'none';
                return;
            }
            
            summaryDiv.style.display = 'block';
            
            let html = `<p><strong>Горизонт:</strong> ${forecastMonthsCount} месяцев</p>`;
            html += `<p><strong>Прогнозные годы:</strong></p>`;
            html += `<ul>`;
            
            forecastPeriods.forEach(period => {
                html += `<li><strong>${period.year}:</strong> ${period.months.length} месяцев `;
                html += `(${period.halfyears.join(', ')}, ${period.quarters.join(', ')})`;
                html += `</li>`;
            });
            
            html += `</ul>`;
            
            contentDiv.innerHTML = html;
        }

        async function updateMetricChart() {
            const select = document.getElementById('metricSelect');
            selectedMetric = select.value;
            
            if (selectedMetric) {
                await loadMetricData();
            }
        }

        function renderMetricChart() {
            const canvas = document.getElementById('metricChart');
            if (!canvas) return;
            
            if (chartInstance) {
                chartInstance.destroy();
            }
            
            if (!metricData.labels || metricData.labels.length === 0) {
                return;
            }
            
            // Подготавливаем данные
            const labels = [...metricData.labels];
            const historicalValues = [...metricData.values];
            const forecastValues = new Array(historicalValues.length).fill(null);
            
            // Добавляем прогнозные периоды (месяцы)
            const forecastPeriods = timelineData.filter(p => p.isForecast);
            
            if (forecastPeriods.length > 0) {
                // Получаем последнее значение фактических данных для соединения линий
                const lastHistoricalValue = historicalValues[historicalValues.length - 1];
                
                // Добавляем прогнозные месяцы
                forecastPeriods.forEach(period => {
                    const label = `${period.year}-${period.month.toString().padStart(2, '0')}`;
                    labels.push(label);
                    historicalValues.push(null);
                    
                    // Для первого прогнозного периода используем последнее фактическое значение
                    // чтобы линия была непрерывной
                    forecastValues.push(lastHistoricalValue);
                });
                
                // Добавляем последнее фактическое значение в начало прогнозной линии
                // чтобы линии соединились
                forecastValues[historicalValues.filter(v => v !== null).length - 1] = lastHistoricalValue;
            }
            
            const ctx = canvas.getContext('2d');
            chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Фактические данные',
                            data: historicalValues,
                            borderColor: '#2196F3',
                            backgroundColor: '#2196F333',
                            borderWidth: 4,
                            pointRadius: 6,
                            pointHoverRadius: 8,
                            tension: 0.2,
                            fill: false
                        },
                        {
                            label: 'Горизонт прогноза',
                            data: forecastValues,
                            borderColor: '#FF9800',
                            backgroundColor: '#FF980033',
                            borderWidth: 4,
                            borderDash: [10, 5],
                            pointRadius: 6,
                            pointHoverRadius: 8,
                            pointStyle: 'rectRot',
                            tension: 0.2,
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `${selectedMetric || 'Метрика'} - Фактические данные и горизонт прогноза`,
                            font: { size: 16, weight: 'bold' }
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.dataset.label || '';
                                    const value = context.parsed.y;
                                    if (value === null) return null;
                                    return `${label}: ${value.toLocaleString('ru-RU')}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Год'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Значение'
                            },
                            beginAtZero: false
                        }
                    }
                }
            });
        }

        async function saveForecastSettings() {
            if (!selectedMetric) {
                alert('Выберите метрику для прогнозирования');
                return;
            }
            
            if (forecastMonthsCount === 0) {
                alert('Задайте горизонт прогноза');
                return;
            }
            
            try {
                const settings = {
                    session_id: currentSessionId,
                    metric: selectedMetric,
                    forecast_months: forecastMonthsCount,
                    forecast_periods: forecastPeriods,
                    time_series_config: timeSeriesConfig
                };
                
                const response = await fetch('/api/save_forecast_settings', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(settings)
                });
                
                const result = await response.json();
                
                if (result.success) {
                    alert(`✅ Настройки прогноза сохранены!\n\nМетрика: ${selectedMetric}\nГоризонт: ${forecastMonthsCount} месяцев`);
                    window.location.href = '/forecast';
                } else {
                    alert('❌ Ошибка: ' + result.message);
                }
            } catch (error) {
                console.error('Ошибка сохранения:', error);
                alert('❌ Ошибка сохранения: ' + error.message);
            }
        }

        function goBack() {
            if (confirm('Вернуться назад? Несохраненные настройки будут потеряны.')) {
                window.location.href = '/forecast';
            }
        }
    </script>
</body>
</html>
