<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MARFOR - Настройка прогноза</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        .btn-primary {
            background-color: #81db99 !important;
            border-color: #81db99 !important;
            color: #000 !important;
        }
        
        .btn-primary:hover {
            background-color: #6bc884 !important;
        }
        
        .calendar-item {
            padding: 8px 12px;
            margin: 4px;
            border-radius: 6px;
            display: inline-block;
            font-size: 0.9em;
            background: #e3f2fd;
            border: 1px solid #2196f3;
        }
        
        .calendar-year {
            font-weight: bold;
            background: #1976d2;
            color: white;
            padding: 10px 15px;
            margin: 10px 0;
            border-radius: 8px;
            cursor: pointer;
        }
        
        .calendar-year:hover {
            background: #1565c0;
        }
        
        .forecast-year {
            background: #ff9800;
            color: white;
        }
        
        .forecast-year:hover {
            background: #f57c00;
        }
        
        .period-selector {
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
            background: #f8f9fa;
        }
        
        .forecast-selector {
            border-color: #ff9800;
            background: #fff3e0;
        }
        
        .period-checkbox {
            margin: 5px;
        }
        
        .selected-periods {
            background: #e8f5e9;
            border: 2px solid #4caf50;
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <!-- Навигация -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container-fluid">
            <a class="navbar-brand d-flex align-items-center" href="/forecast">
                <img src="/static/images/logo.png" alt="MARFOR Logo" height="32" class="me-2" style="object-fit: contain;">
                <strong>MARFOR</strong>
            </a>
            <span class="navbar-text">
                <i class="fas fa-cog me-2"></i>Настройка прогноза
            </span>
            <div class="ms-auto">
                <span class="badge bg-success" style="font-size: 0.8em;">
                    <i class="fas fa-code"></i> v2.17.0
                </span>
            </div>
        </div>
    </nav>

    <!-- Основной контент -->
    <div class="container-fluid mt-4">
        <div class="row">
            <div class="col-12">
                <!-- Выбор метрики -->
                <div class="card mb-3">
                    <div class="card-header bg-primary text-dark">
                        <h6 class="mb-0">
                            <i class="fas fa-chart-bar me-2"></i>Выбор метрики для прогнозирования
                        </h6>
                    </div>
                    <div class="card-body">
                        <div class="row align-items-center">
                            <div class="col-md-4">
                                <label class="form-label">Метрика:</label>
                                <select id="metricSelect" class="form-select" onchange="updateMetricChart()">
                                    <option value="">Загрузка...</option>
                                </select>
                            </div>
                            <div class="col-md-8">
                                <div class="alert alert-info mb-0">
                                    <i class="fas fa-info-circle me-2"></i>
                                    Выберите метрику, для которой будет построен прогноз. График автоматически обновится.
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- График метрики -->
                <div class="card mb-3">
                    <div class="card-header bg-primary text-dark">
                        <h6 class="mb-0">
                            <i class="fas fa-chart-line me-2"></i>График выбранной метрики
                        </h6>
                    </div>
                    <div class="card-body">
                        <canvas id="metricChart" style="height: 400px; width: 100%;"></canvas>
                    </div>
                </div>

                <!-- Календарь временных рядов -->
                <div class="card mb-3">
                    <div class="card-header bg-primary text-dark">
                        <h6 class="mb-0">
                            <i class="fas fa-calendar-alt me-2"></i>Календарь временных рядов и настройка горизонта прогноза
                        </h6>
                    </div>
                    <div class="card-body">
                        <div class="row">
                            <!-- Фактические данные -->
                            <div class="col-md-6">
                                <h6 class="mb-3">
                                    <i class="fas fa-database me-2"></i>Фактические данные
                                </h6>
                                <div id="historicalCalendar" style="max-height: 500px; overflow-y: auto;">
                                    Загрузка...
                                </div>
                            </div>

                            <!-- Горизонт прогноза -->
                            <div class="col-md-6">
                                <h6 class="mb-3">
                                    <i class="fas fa-calendar-plus me-2 text-warning"></i>Горизонт прогноза
                                    <button class="btn btn-sm btn-success ms-3" onclick="addForecastYear()">
                                        <i class="fas fa-plus me-1"></i>Добавить год
                                    </button>
                                </h6>
                                <div id="forecastCalendar" style="max-height: 500px; overflow-y: auto;">
                                    <p class="text-muted">Нажмите "Добавить год" для создания прогнозного периода</p>
                                </div>
                                
                                <!-- Сводка выбранных периодов -->
                                <div id="selectedPeriodsSummary" class="mt-3" style="display: none;">
                                    <div class="selected-periods">
                                        <h6><i class="fas fa-check-circle me-2"></i>Выбрано для прогноза:</h6>
                                        <div id="summaryContent"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Кнопки действий -->
                <div class="text-center mb-4">
                    <button class="btn btn-secondary btn-lg me-3" onclick="goBack()">
                        <i class="fas fa-arrow-left me-2"></i>Назад
                    </button>
                    <button class="btn btn-success btn-lg" onclick="saveForecastSettings()">
                        <i class="fas fa-save me-2"></i>Сохранить и запустить прогноз
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        let currentSessionId = null;
        let timeSeriesConfig = null;
        let existingTimeSeries = [];
        let forecastPeriods = [];
        let chartInstance = null;
        let metrics = [];
        let selectedMetric = null;
        let metricData = {};

        // Инициализация при загрузке страницы
        document.addEventListener('DOMContentLoaded', async function() {
            // Получаем session_id из URL
            const urlParams = new URLSearchParams(window.location.search);
            currentSessionId = urlParams.get('session_id') || sessionStorage.getItem('currentSessionId');
            
            if (!currentSessionId) {
                alert('Сессия не найдена. Вернитесь на главную страницу.');
                window.location.href = '/forecast';
                return;
            }
            
            await loadData();
        });

        async function loadData() {
            try {
                // Получаем маппинг из sessionStorage
                const mappingStr = sessionStorage.getItem('dataMapping');
                const mapping = mappingStr ? JSON.parse(mappingStr) : null;
                
                if (!mapping || !mapping.columns) {
                    alert('Настройки маппинга не найдены. Вернитесь на страницу маппинга.');
                    window.location.href = '/forecast/mapping';
                    return;
                }
                
                // Находим метрики и временные поля
                metrics = [];
                timeSeriesConfig = {};
                
                mapping.columns.forEach(col => {
                    if (col.role === 'metric' && col.include) {
                        metrics.push({
                            name: col.name,
                            displayName: col.name
                        });
                    }
                    if (col.time_series && col.include) {
                        timeSeriesConfig[col.time_series] = col.name;
                    }
                });
                
                console.log('Метрики:', metrics);
                console.log('Временные поля:', timeSeriesConfig);
                
                // Заполняем select метрик
                populateMetricSelect();
                
                // Загружаем временные ряды
                await loadTimeSeries();
                
                // Отображаем календарь
                renderCalendar();
                
                // Загружаем данные для графика
                await loadMetricData();
                
            } catch (error) {
                console.error('Ошибка загрузки данных:', error);
                alert('Ошибка загрузки данных: ' + error.message);
            }
        }

        function populateMetricSelect() {
            const select = document.getElementById('metricSelect');
            select.innerHTML = '';
            
            if (metrics.length === 0) {
                select.innerHTML = '<option value="">Метрики не найдены</option>';
                return;
            }
            
            metrics.forEach((metric, index) => {
                const option = document.createElement('option');
                option.value = metric.name;
                option.text = metric.displayName;
                if (index === 0) {
                    option.selected = true;
                    selectedMetric = metric.name;
                }
                select.appendChild(option);
            });
        }

        async function loadTimeSeries() {
            try {
                const response = await fetch(`/api/get_time_series_values/${currentSessionId}`);
                const result = await response.json();
                
                if (result.success) {
                    existingTimeSeries = result.time_series;
                    console.log('Загружено временных рядов:', existingTimeSeries.length);
                    console.log('Первые 5 записей:', existingTimeSeries.slice(0, 5));
                    
                    // Детальный вывод первой записи
                    if (existingTimeSeries.length > 0) {
                        const first = existingTimeSeries[0];
                        console.log('Детали первой записи:', {
                            year: first.year,
                            yearType: typeof first.year,
                            halfyear: first.halfyear,
                            quarter: first.quarter,
                            month: first.month,
                            allKeys: Object.keys(first)
                        });
                    }
                } else {
                    console.error('Ошибка:', result.message);
                }
            } catch (error) {
                console.error('Ошибка загрузки временных рядов:', error);
            }
        }

        async function loadMetricData() {
            if (!selectedMetric) return;
            
            try {
                // Запрашиваем агрегированные данные по выбранной метрике
                const response = await fetch(`/api/get_metric_time_series/${currentSessionId}?metric=${selectedMetric}`);
                const result = await response.json();
                
                if (result.success) {
                    metricData = result.data;
                    console.log('Данные метрики загружены:', metricData);
                    renderMetricChart();
                } else {
                    console.error('Ошибка загрузки данных метрики:', result.message);
                }
            } catch (error) {
                console.error('Ошибка:', error);
            }
        }

        function renderCalendar() {
            renderHistoricalCalendar();
            renderForecastCalendar();
            updateSummary();
        }

        function renderHistoricalCalendar() {
            const container = document.getElementById('historicalCalendar');
            
            if (existingTimeSeries.length === 0) {
                container.innerHTML = '<p class="text-muted">Нет данных</p>';
                return;
            }
            
            // Группируем данные в иерархическую структуру
            const hierarchy = {};
            
            existingTimeSeries.forEach(item => {
                const year = item.year;
                
                // Проверка наличия года
                if (!year || year === '' || year === null || year === undefined) {
                    console.warn('Запись без года:', item);
                    return; // Пропускаем записи без года
                }
                
                if (!hierarchy[year]) {
                    hierarchy[year] = {};
                }
                
                // Строим путь: year/halfyear/quarter/month
                let currentLevel = hierarchy[year];
                
                if (item.halfyear) {
                    // halfyear может быть "H1" или просто "1"
                    const hy = item.halfyear.toString().startsWith('H') ? item.halfyear : `H${item.halfyear}`;
                    if (!currentLevel[hy]) {
                        currentLevel[hy] = {};
                    }
                    currentLevel = currentLevel[hy];
                }
                
                if (item.quarter) {
                    // quarter может быть "Q1", "QQ1" или просто "1"
                    let q = item.quarter.toString();
                    if (q.startsWith('QQ')) {
                        q = q.substring(1); // Убираем один Q из QQ1
                    } else if (!q.startsWith('Q')) {
                        q = `Q${q}`;
                    }
                    if (!currentLevel[q]) {
                        currentLevel[q] = {};
                    }
                    currentLevel = currentLevel[q];
                }
                
                if (item.month) {
                    const m = item.month.toString();
                    currentLevel[m] = true;
                }
            });
            
            console.log('Иерархия данных:', hierarchy);
            
            let html = '';
            
            // Рекурсивная функция для отображения иерархии
            function renderLevel(data, level = 0, parentPath = '') {
                let result = '';
                const indent = level * 20;
                
                Object.keys(data).sort((a, b) => {
                    // Сортировка: числа по возрастанию, строки по алфавиту
                    const aNum = parseInt(a.replace(/[^0-9]/g, ''));
                    const bNum = parseInt(b.replace(/[^0-9]/g, ''));
                    if (!isNaN(aNum) && !isNaN(bNum)) return aNum - bNum;
                    return a.localeCompare(b);
                }).forEach(key => {
                    const value = data[key];
                    const path = parentPath ? `${parentPath}/${key}` : key;
                    
                    result += `<div style="margin-left: ${indent}px; margin-top: 5px;">`;
                    
                    // Определяем стиль в зависимости от уровня
                    let itemClass = 'calendar-item';
                    if (level === 0) {
                        // Год
                        itemClass += ' bg-primary text-white fw-bold';
                    } else if (key.startsWith('H')) {
                        // Полугодие
                        itemClass += ' bg-info text-white';
                    } else if (key.startsWith('Q')) {
                        // Квартал
                        itemClass += ' bg-secondary text-white';
                    } else {
                        // Месяц
                        itemClass += ' bg-light';
                    }
                    
                    result += `<span class="${itemClass}">${key}</span>`;
                    
                    // Если есть вложенные элементы, отображаем их
                    if (typeof value === 'object' && Object.keys(value).length > 0) {
                        result += renderLevel(value, level + 1, path);
                    }
                    
                    result += `</div>`;
                });
                
                return result;
            }
            
            html = renderLevel(hierarchy);
            container.innerHTML = html;
        }

        function renderForecastCalendar() {
            const container = document.getElementById('forecastCalendar');
            
            if (forecastPeriods.length === 0) {
                container.innerHTML = '<p class="text-muted">Нажмите "Добавить год" для создания прогнозного периода</p>';
                return;
            }
            
            let html = '';
            
            forecastPeriods.forEach((period, yearIndex) => {
                html += `<div class="mb-3">`;
                html += `<div class="calendar-year forecast-year d-flex justify-content-between align-items-center">`;
                html += `<span>${period.year}</span>`;
                html += `<button class="btn btn-sm btn-danger" onclick="removeForecastYear(${yearIndex})">`;
                html += `<i class="fas fa-times"></i></button>`;
                html += `</div>`;
                
                html += `<div class="period-selector forecast-selector">`;
                
                // Полугодия
                if (timeSeriesConfig.halfyear) {
                    html += `<div class="mb-3">`;
                    html += `<label class="form-label fw-bold">Полугодия:</label><br>`;
                    ['H1', 'H2'].forEach(hy => {
                        const checked = period.halfyears.includes(hy) ? 'checked' : '';
                        html += `<div class="form-check form-check-inline period-checkbox">`;
                        html += `<input class="form-check-input" type="checkbox" id="hy-${yearIndex}-${hy}" value="${hy}" ${checked} onchange="updateForecastPeriod(${yearIndex})">`;
                        html += `<label class="form-check-label" for="hy-${yearIndex}-${hy}">${hy}</label>`;
                        html += `</div>`;
                    });
                    html += `</div>`;
                }
                
                // Кварталы
                if (timeSeriesConfig.quarter) {
                    html += `<div class="mb-3">`;
                    html += `<label class="form-label fw-bold">Кварталы:</label><br>`;
                    for (let q = 1; q <= 4; q++) {
                        const qLabel = `Q${q}`;
                        const checked = period.quarters.includes(qLabel) ? 'checked' : '';
                        html += `<div class="form-check form-check-inline period-checkbox">`;
                        html += `<input class="form-check-input" type="checkbox" id="q-${yearIndex}-${q}" value="${qLabel}" ${checked} onchange="updateForecastPeriod(${yearIndex})">`;
                        html += `<label class="form-check-label" for="q-${yearIndex}-${q}">${qLabel}</label>`;
                        html += `</div>`;
                    }
                    html += `</div>`;
                }
                
                // Месяцы
                if (timeSeriesConfig.month) {
                    html += `<div class="mb-3">`;
                    html += `<label class="form-label fw-bold">Месяцы:</label><br>`;
                    for (let m = 1; m <= 12; m++) {
                        const checked = period.months.includes(m) ? 'checked' : '';
                        html += `<div class="form-check form-check-inline period-checkbox" style="width: 60px;">`;
                        html += `<input class="form-check-input" type="checkbox" id="m-${yearIndex}-${m}" value="${m}" ${checked} onchange="updateForecastPeriod(${yearIndex})">`;
                        html += `<label class="form-check-label" for="m-${yearIndex}-${m}">${m}</label>`;
                        html += `</div>`;
                    }
                    html += `</div>`;
                }
                
                html += `</div>`;
                html += `</div>`;
            });
            
            container.innerHTML = html;
        }

        function addForecastYear() {
            // Определяем максимальный год
            let maxYear = 0;
            
            if (existingTimeSeries.length > 0) {
                maxYear = Math.max(...existingTimeSeries.map(d => d.year || 0));
            }
            
            if (forecastPeriods.length > 0) {
                maxYear = Math.max(maxYear, ...forecastPeriods.map(p => p.year));
            }
            
            const newYear = maxYear + 1;
            
            // Добавляем новый период
            forecastPeriods.push({
                year: newYear,
                halfyears: [],
                quarters: [],
                months: []
            });
            
            renderForecastCalendar();
            updateSummary();
            renderMetricChart();
        }

        function removeForecastYear(index) {
            if (confirm(`Удалить прогнозный период для ${forecastPeriods[index].year} года?`)) {
                forecastPeriods.splice(index, 1);
                renderForecastCalendar();
                updateSummary();
                renderMetricChart();
            }
        }

        function updateForecastPeriod(yearIndex) {
            const period = forecastPeriods[yearIndex];
            
            // Обновляем полугодия
            period.halfyears = [];
            ['H1', 'H2'].forEach(hy => {
                const checkbox = document.getElementById(`hy-${yearIndex}-${hy}`);
                if (checkbox && checkbox.checked) {
                    period.halfyears.push(hy);
                }
            });
            
            // Обновляем кварталы
            period.quarters = [];
            for (let q = 1; q <= 4; q++) {
                const checkbox = document.getElementById(`q-${yearIndex}-${q}`);
                if (checkbox && checkbox.checked) {
                    period.quarters.push(`Q${q}`);
                }
            }
            
            // Обновляем месяцы
            period.months = [];
            for (let m = 1; m <= 12; m++) {
                const checkbox = document.getElementById(`m-${yearIndex}-${m}`);
                if (checkbox && checkbox.checked) {
                    period.months.push(m);
                }
            }
            
            console.log('Обновлен период:', period);
            updateSummary();
            renderMetricChart();
        }

        function updateSummary() {
            const summaryDiv = document.getElementById('selectedPeriodsSummary');
            const contentDiv = document.getElementById('summaryContent');
            
            if (forecastPeriods.length === 0) {
                summaryDiv.style.display = 'none';
                return;
            }
            
            summaryDiv.style.display = 'block';
            
            let html = '';
            let totalPeriods = 0;
            
            forecastPeriods.forEach(period => {
                const parts = [];
                if (period.halfyears.length > 0) parts.push(`${period.halfyears.length} полугодий`);
                if (period.quarters.length > 0) parts.push(`${period.quarters.length} кварталов`);
                if (period.months.length > 0) parts.push(`${period.months.length} месяцев`);
                
                const count = period.months.length || period.quarters.length || period.halfyears.length || 0;
                totalPeriods += count;
                
                if (parts.length > 0) {
                    html += `<div><strong>${period.year}:</strong> ${parts.join(', ')}</div>`;
                }
            });
            
            html += `<div class="mt-2"><strong>Всего периодов для прогноза: ${totalPeriods}</strong></div>`;
            
            contentDiv.innerHTML = html;
        }

        async function updateMetricChart() {
            const select = document.getElementById('metricSelect');
            selectedMetric = select.value;
            
            if (selectedMetric) {
                await loadMetricData();
            }
        }

        function renderMetricChart() {
            const canvas = document.getElementById('metricChart');
            if (!canvas) return;
            
            // Уничтожаем предыдущий график
            if (chartInstance) {
                chartInstance.destroy();
            }
            
            if (!metricData.labels || metricData.labels.length === 0) {
                return;
            }
            
            // Подготавливаем данные
            const labels = [...metricData.labels];
            const historicalValues = [...metricData.values];
            const forecastValues = new Array(historicalValues.length).fill(null);
            
            // Добавляем прогнозные периоды
            forecastPeriods.forEach(period => {
                labels.push(period.year.toString());
                historicalValues.push(null);
                // Пока ставим 0, позже здесь будет реальный прогноз
                forecastValues.push(0);
            });
            
            const ctx = canvas.getContext('2d');
            chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Фактические данные',
                            data: historicalValues,
                            borderColor: '#2196F3',
                            backgroundColor: '#2196F333',
                            borderWidth: 4,
                            pointRadius: 6,
                            pointHoverRadius: 8,
                            tension: 0.2,
                            fill: false
                        },
                        {
                            label: 'Горизонт прогноза',
                            data: forecastValues,
                            borderColor: '#FF9800',
                            backgroundColor: '#FF980033',
                            borderWidth: 4,
                            borderDash: [10, 5],
                            pointRadius: 6,
                            pointHoverRadius: 8,
                            pointStyle: 'rectRot',
                            tension: 0.2,
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `${selectedMetric || 'Метрика'} - Фактические данные и горизонт прогноза`,
                            font: { size: 16, weight: 'bold' }
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.dataset.label || '';
                                    const value = context.parsed.y;
                                    if (value === null) return null;
                                    return `${label}: ${value.toLocaleString('ru-RU')}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Период'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Значение'
                            },
                            beginAtZero: false
                        }
                    }
                }
            });
        }

        async function saveForecastSettings() {
            if (!selectedMetric) {
                alert('Выберите метрику для прогнозирования');
                return;
            }
            
            if (forecastPeriods.length === 0) {
                alert('Добавьте хотя бы один прогнозный период');
                return;
            }
            
            // Проверяем, что в каждом периоде выбрано что-то
            const emptyPeriods = forecastPeriods.filter(p => 
                p.halfyears.length === 0 && p.quarters.length === 0 && p.months.length === 0
            );
            
            if (emptyPeriods.length > 0) {
                alert('Для каждого года необходимо выбрать хотя бы один период (полугодие, квартал или месяц)');
                return;
            }
            
            try {
                const settings = {
                    session_id: currentSessionId,
                    metric: selectedMetric,
                    forecast_periods: forecastPeriods,
                    time_series_config: timeSeriesConfig
                };
                
                const response = await fetch('/api/save_forecast_settings', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(settings)
                });
                
                const result = await response.json();
                
                if (result.success) {
                    alert('✅ Настройки прогноза сохранены!\n\nТеперь можно запустить прогнозирование.');
                    // Пока вернемся на главную, позже добавим страницу запуска прогноза
                    window.location.href = '/forecast';
                } else {
                    alert('❌ Ошибка: ' + result.message);
                }
            } catch (error) {
                console.error('Ошибка сохранения:', error);
                alert('❌ Ошибка сохранения: ' + error.message);
            }
        }

        function goBack() {
            if (confirm('Вернуться назад? Несохраненные настройки будут потеряны.')) {
                window.location.href = '/forecast';
            }
        }
    </script>
</body>
</html>
